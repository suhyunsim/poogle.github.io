---
layout: post
title: "Java 면접 질문 모음 - 작성중"
author: "Poogle"
categories: [BackEnd]
sitemap:
changefreq: daily
priority: 1.0
comments: true
tag: [Java]

---

> 참고 링크
>
> [자바 기초 - 개발 환경](https://suhyunsim.github.io/2021-08-02/%EC%9E%90%EB%B0%94%EA%B8%B0%EC%B4%88-%ED%99%98%EA%B2%BD)
> 
> [[JAVA] 자바 프로그램 실행 과정 및 기본 구조](https://pienguin.tistory.com/entry/JAVA-%EC%9E%90%EB%B0%94-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95-%EB%B0%8F-%EA%B8%B0%EB%B3%B8-%EA%B5%AC%EC%A1%B0)
> 
> [인프런 - 더 자바, 코드를 조작하는 다양한 방법](https://www.inflearn.com/course/the-java-code-manipulation/dashboard)
> 
> [Naver D2 - Java Garbage Collection](https://d2.naver.com/helloworld/1329)
>
> [f-lab - 자바 백엔드 기술 면접 대비하기 - 1편](https://f-lab.kr/blog/java-backend-interview-1)
>
> [f-lab - 자바 백엔드 기술 면접 대비하기 - 2편 (고급편)](https://f-lab.kr/blog/java-backend-interview-2)
> 

# Java 면접 질문 

자바의 모든 클래스는 Object 클래스를 상속받습니다. 그리고 Object클래스에는 equals() 와 hashCode() 라는 메소드가 선언되어 있습니다. 이 메소드들은 각각 어떤 역할일까요? 이 둘의 차이점은 무엇일까요?
StringBuilder 와 StringBuffer 의 차이는 무엇일까요?
System.out.println 메소드는 현업에서 절대 쓰지 말라고하는 메소드인데요. 그 이유가 무엇일까요?
ArrayList 는 내부적으로 어떻게 구현되어있을까요?
스레드는 왜 써야하는 것일까요?
0이 들어있는 변수에 10개의 스레드가 동시에 접근해서 ++ 연산을 하면 우리 예상과 다르게 10이 나오지 않습니다. 왜 그럴까요?
자바에서 동시성과 관련된 예약어를 모두 말씀해주세요.
Blocking IO와 Non-Blocking IO 의 차이를 말씀해주세요.
Serializable 은 무엇일까요?


# 📌 Java 구조, JVM

![IMG_B167E3C90164-1](https://user-images.githubusercontent.com/58318786/229297496-4b45bf25-b812-4718-8732-1d3887e20135.jpeg)
![IMG_6E7C313D815F-1](https://user-images.githubusercontent.com/58318786/229297486-1b1964cf-8523-46f3-b73c-9e264e8c8138.jpeg)

## ❓ JVM, JRE, JDK에 대해 설명해주세요.
![IMG_9769BFA1EE41-1](https://user-images.githubusercontent.com/58318786/229308329-0577a0cb-71c5-46de-9671-0e3f9901d23f.jpeg)

### JVM(Java Virtual Machine); 자바 가상 머신
- 자바 바이트 코드를 OS에 특화된 코드로 변환하여 실행하는 구현체입니다.
- 표준화된 JVM 스펙을 기준으로 이를 구현한 다양한 JVM 벤더 들이 있습니다.(ex. Oracle, Amazon ...)

#### ❓❓ '플랫폼 종속적'이라는 키워드를 설명해주세요.
* Java 프로그램은 JVM 덕분에 플랫폼에 독립적입니다.
  * 중간 단계 언어인 바이트 파일로 컴파일 되기 때문에 OS마다 따로 코드를 작성해야 하는 번거로움이 없습니다.
* JVM은 플랫폼에 종속됩니다.
  * Mac, Windows에 설치되는 JVM이 구분됩니다.
* JDK, JRE는 플랫폼에 독립적입니다.

### JRE(Java Runtime Environment); 자바 실행 환경
* 자바 애플리케이션을 실행할 수 있도록 구현된 배포판입니다.
* `JVM + 라이브러리`
  * JVM과 핵심 라이브러리 및 자바 런타임 환경에서 사용되는 프로퍼티 세팅이나 리소스 파일을 가지고 있습니다.
* 개발 관련 도구들은 포함하지 않습니다.

### JDK(Java Development Kit); 자바 개발 키트
* `JRE + 개발 관련 도구`
* 과거 JRE와 JDK를 구분해서 배포했던 것과 달리 오라클은 Java11부터는 JDK만 제공합니다.

<br>

## ❓ JVM의 구조에 대해 설명해주세요.

![JVM](https://user-images.githubusercontent.com/58318786/229801877-9faee090-ba25-48e9-9f03-d7ab91bba5f9.jpg)

### [Class Loader]
* `.class`에서 바이트코드를 읽고 메모리에 저장해 JVM 내로 클래스를 로드하는 모듈입니다.

#### Loading
* **Bootstrap** -> **Extension(Platform)** -> **Application**
* 클래스 로더가 `.class` 파일을 읽어 그 내용에 따라 적절한 바이너리 데이터를 만들고 `Method Area`에 저장합니다.
* `Method Area`에 저장하는 데이터
  * FQCN(Fully Qualified Class Name); 패키지 경로까지 포함한 이름
  * class, interface, enum
  * method와 변수
* 로딩이 끝나면 해당 클래스 타입의 `클래스 객체`를 생성해 `Heap` 영역에 저장합니다.
* 해당 시점에서 클래스가 없으면 `ClassNotFoundException`이 발생합니다.

#### Link
* 레퍼런스를 연결합니다.
* **Verify**: `.class`파일이 유효한지 체크합니다.
* **Prepare**: 클래스 변수(static 변수)와 기본값에 필요한 메모리를 준비합니다.
* **Resolve**: 심볼릭 메모리 레퍼런스(논리적인 레퍼런스)를 `method area`에 있는 실제 레퍼런스로 교체합니다. (_optional_)

#### Initialization
* 준비한 메모리에 static 값들을 초기화하고, 변수에 할당합니다.

### [Execution Engine]
* 바이트 코드를 실행시키는 역할을 합니다.
* **Interpreter**: 바이트 코드를 한 줄씩 실행합니다.
* **JIT(Just-In-Time Compiler) Compiler**
  * 인터프리터 효율을 높이기 위한 컴파일러로 인터프리터가 반복되는 코드를 발견하면 JIT컴파일러가 반복되는 코드를 네이티브 코드(캐시에 보관)로 바꿔줍니다. 
  * 그 후 인터프리터는 네이티브 코드로 컴파일된 코드를 바로 사용합니다.
* **Garbage Collector**
  * 힙 영역에서 사용되지 않는 객체들을 제거합니다.
  * 유효하지 않은 메모리, 즉 주소를 잃어버려 사용할 수 없는 메모리들을 해제 시켜 다른 용도로 사용할 수 있게 해줍니다.

### [Runtime Data Areas]
* 프로그램 실행 중에 사용되는 다양한 영역입니다.

#### Stack Area
* 스레드마다 런타임 스택을 만들고 그 안에 메소드 호출을 스택 프레임 블럭으로 쌓습니다. 스레드가 종료되면 런타임 스택도 사라집니다.
* Method 안에서 사용되는 값들(매개변수, 지역변수, 리턴 값 등)이 생성되며 실제 객체는 Heap에 할당되고 해당 레퍼런스만 Stack에 저장됩니다.

#### PC Register
* 스레드가 시작될 때 생성되며 현재 수행중인 JVM 명령의 주소를 갖고 있습니다. 
* 스레드마다 스레드 내 현재 실행할 스택 프레임을 가리키는 포인터가 생성됩니다.

#### Native Method Stack
* 각 스레드마다 생성됩니다.
* 다른 언어(C, C++, 어셈블리어로 구축)의 메서드 호출을 위해 할당되는 구역입니다.
  * 이미 다른 언어로 작성되어 자바로 재작성할 필요가 없거나,
  * 시스템 디바이스에 접근하거나 플랫폼 특정 작업을 할 떄 성능 향상을 위해 이러한 `native` 메서드를 사용합니다.

#### Heap Area
* 모든 스레드에게 공유되는 자원입니다.
* 동적으로 생성된 오브젝트(인스턴스와 객체)와 배열이 저장되는 곳입니다.
* 공간이 부족해지면 GC의 대상이 되는 영역입니다.

#### Method Area(Static Area)
* 모든 스레드에게 공유되는 자원입니다.
* 클래스 수준의 정보(클래스 멤버 변수, 메소드 정보, Type 정보, Constant Pool(모든 Symbolic Reference를 포함), static, final 변수) 등이 생성됩니다.

### [Native Method Interface; JNI(Java Native Interface)]
* 자바 어플리케이션에서 C, C++ 어셈블리어로 작성된 함수를 사용할 수 있는 방법(표준 규약)을 제공해줍니다.
* 자바 프로그램이 네이티브 메서드를 호출하는 기술입니다.
* `native` 키워드를 사용해서 메서드를 호출합니다. 
* ex. Thread의 `currentThread()`

#### _cf.) Effective Java Item.66: 네이티브 메서드는 신중히 사용하라_
* _Native Method 네이티브 메서드의 쓰임_
  * _레지스트리 같은 플랫폼 특화 기능 사용 시 (-> 자바가 성숙해지면서 사용할 필요가 줄어들음)_
  * _네이티브 코드로 작성된 기존 라이브러리 사용 시_
  * _성능 개선 영향 영역만 따로 작성 시_
* _⚠️ BUT 네이티브 언어는 메모리 훼손 오류로부터 안전하지 않음, 네이티브 메서드가 성능을 개선해주는 일은 많지 않음(때로는 이식성 문제가 있거나 디버깅이 어려워서 성능을 더 낮추기도 함)_

### [Native Method Library]
* C, C++로 작성된 라이브러리 입니다.

<br>

## ❓ JVM의 구조와 함께 Java의 실행방식을 설명해주세요.

* 자바 컴파일러(javac)가 자바 소스코드(`.java`)를 읽어 자바 바이트코드(`.class`)로 변환시킵니다.
* Class Loader를 통해 class 파일들을 JVM으로 로딩합니다.
* 로딩된 class파일들은 Execution Engine을 통해 해석됩니다.
* 해석된 바이트코드는 Runtime Data Areas 에 배치되어 실질적인 수행이 이루어집니다.

<br>

## ❓ 바이트 코드(byte code)란 무엇인가요?
* `.java` 소스파일을 컴파일 후 생성되는 `.class`(확장자) 파일로 JVM이 읽어서 기계어로 해석할 수 있는 소스 코드를 의미합니다.
* 자바 컴파일러에 의해 변환되는 코드의 명령어 크기가 1byte이기 때문에 byte code라고 불립니다.

<br>

## ❓ Java 성능에 대한 이슈와 관련지어 JIT에 대해 설명해주세요.
* 자바의 특징으로 인터프리터를 하는 과정, 그리고 그 전의 컴파일 과정 때문에 느리다는 인식이 있었습니다.
  * 바이트코드로 한 번 컴파일하는 과정
  * 바이트코드를 인터프리터로 읽어가는 과정(런타임 시 한 줄씩)
* 자바는 컴파일 방식과 인터프리터 방식을 모두 사용하기 때문에 JIT 컴파일러를 도입해 반복되는 코드를 네이티브 코드로 컴파일해 인터프리터가 바로 사용할 수 있도록, 그로 인해 빠른 성능을 가질 수 있도록 합니다.

### ❓❓ AOT 컴파일은 무엇일까요?

### ❓❓ C1 컴파일러와 C2 컴파일러는 무엇이고 역할이 어떻게 다를까요?

### ❓❓ 컴파일 과정에서 컴파일러가 최적화해주는 것들은 무엇이 있을까요?
* JVM 컴파일러 최적화 
* hotspot compiler optimization

+연산을 StringBuilder로 변환해주기
반복문 펼쳐주기
탈출분석
인라이닝
Etc...

<br>

## ❓ GC가 무엇이고 필요한 이유와 동작 방식에 대해 설명해주세요.
* Java에서는 개발자가 프로그램 코드로 메모리를 명시적으로 해제하지 않기 때문에 가비지 컬렉터(Garbage Collector)가 더 이상 필요 없는 (쓰레기) 객체를 찾아 지우는 작업을 합니다.
* GC는 힙 메모리만 다룹니다.
* GC의 대상
  * 객체가 NULL인 경우
  * 블럭 실행 종료 후 블럭 안에서 생성된 객체
  * 부모 객체가 NULL인 경우, 포함하는 자식 객체
* 관련 가설; `weak generational hypothesis`
  * 대부분의 객체는 금방 접근 불가능 상태(unreachable)가 된다.
  * 오래된 객체에서 젊은 객체로의 참조는 아주 적게 존재한다.

### ❓❓ 개발자가 메모리에 대해 신경을 덜 쓸 수 있어서 편해지는데, 그에 따른 단점은 없을까요?
* **stop-the-world**
  * GC를 실행하기 위해 JVM이 애플리케이션 실행을 멈추는 것을 의미하는데, stop-the-world가 발생하면 GC를 실행하는 쓰레드를 제외한 나머지 쓰레드는 모두 작업을 멈춥니다.
  * GC 작업을 완료한 후 중단한 작업을 다시 시작합니다.
  * => GC 튜닝은 stop-the-world 시간을 줄이는 것을 의미합니다.

<br>

### GC의 물리적 공간 구분

![IMG_69E9CC5F4128-1](https://user-images.githubusercontent.com/58318786/229897440-b44ff0a6-1818-4799-969f-3f6bbba616fa.jpeg)

#### Young Generation 영역
* 새롭게 생성한 객체의 대부분이 위치하는 영역입니다.
* 대부분의 객체가 금방 접근 불가능 상태가 되기 때문에 많은 객체가 Young 영역에 생성되었다가 사라집니다.
* 이 때 `Minor GC`가 발생합니다.
* `Eden` + `Survivor 1` + `Survivor 2`
  * 새로 생성한 대부분의 객체가 위치
  * GC 한 번 발생 후 살아남은 객체는 Survivor 중 하나로 이동
  * GC 발생하면 위 Survivor 영역에 객체가 계속 쌓임
  * 하나의 Survivor가 가득 차면 그 중 살아남은 객체를 다른 Survivor로 이동, 가득찬 곳은 아무 데이터도 없는 상태로 됨(둘 중 하나는 비어있음)
  * 위 과정 반복 후 살아남은 객체는 Old영역으로 이동

#### Old Generation 영역
* 접근 불가능 상태로 되지 않아 Young 영역에서 살아남은 객체가 여기로 복사됩니다.
* 대부분 Young 영역보다 크게 할당하며, 큰 만큼 Young보다 GC가 적게 발생합니다.
* 이 때 `Major GC`가 발생합니다. (`stop-the-world` 발생)
* Serial GC, Parallel GC, Parallel Old GC, CMS, G1GC(Garbage First GC) 등

<br>

### ❓❓ 개발자가 GC 튜닝을 하는 궁극적인 목표는 무엇일까요?
* 빠른 처리 속도를 달성하면서 `stop-the-world`의 최소화를 충족시키는 것이 목표입니다.

### ❓❓❓ G1GC부터는 GC튜닝에 크게 손이 가진 않는데, G1GC는 어떻게 만들었길래 개발자가 튜닝을 이전보다 덜 해도 되는걸까요?
* G1GC는 바둑판의 각 영역에 객체를 할당하고 GC를 실행합니다.
* 그러다가, 해당 영역이 꽉 차면 다른 영역에서 객체를 할당하고 GC를 실행합니다. (Young -> Old 단계 사라짐, CMS GC의 문제 해결)
* 기존 GC와는 다르게 Eden, Survivor, Old 영역이 고정된 크기가 아니며 전체 힙 메모리 영역을 `Region`이라는 특정한 크기로 나누고 `Region`의 상태에 따라 역할이 동적으로 변동합니다.
* 장점: GC 방식 중에 `stop-the-world`시간이 제일 짧습니다.

> https://youtu.be/FMUpVA0Vvjw
> https://velog.io/@recordsbeat/Low-Pause-Shenandoah-GC

## ❓ 힙에 메모리를 할당하는 과정에서 어떤 일들이 벌어지나요?

### ❓❓ TLAB이란 무엇일까요?

Thread Local Allocation Buffer
이것은 어떤 문제를 해결하기 위해 만들어진 것일까요?
💡 멀티 스레드 환경에서 락을 분산시켜 성능을 향상시키는 이와 유사한 기법이 많습니다. 어플리케이션을 개발하면서 다른 곳들도 잘 찾아보세요 🙂


<br>

---

<br>

# 📌 Object 클래스 - `equals()`, `hashCode()`

## ❓ 자바의 모든 클래스는 Object 클래스를 상속받습니다. 그리고 Object클래스에는 equals() 와 hashCode() 라는 메소드가 선언되어 있습니다. 이 메소드들은 각각 어떤 역할일까요? 이 둘의 차이점은 무엇일까요?
* **동일성(identity)**: 메모리상 주소값이 일치하는지를 의미합니다.
  * `==` 비교
  * 객체 인스턴스의 주소 값을 비교합니다.
  * primitive data type의 경우 `==`을 통해 값 비교가 가능합니다.
    * 변수 선언부 -> Stack Area / 해당 변수에 저장된 상수 -> Runtime Constant Pool
    * 변수 선언부는 해당 Runtime Constant Pool의 주소값을 가지게 되고 만약 다른 변수도 같은 상수를 저장하고 있다면 같은 주소값을 가지게 되기 때문에 주소값 비교가 가능합니다.
* `hashCode()`
  * 객체의 주소값을 이용하여 객체 고유의 해시코드를 반환합니다.
* **동등성(equality)**: 논리적 지위가 동등한지를 의미합니다.
  * 객체 내부의 값을 비교합니다.
* `equals()`
  * 객체의 값의 일치 여부를 반환하는데 논리적으로 동등한지(참조값이 다르더라도 객체 내부 value는 같음)를 판단합니다.
  * String class는 `eqauls()` 메서드를 재정의해서 문자열 값을 비교합니다.


잘못 답변할 수 있는 케이스
"hashCode"는 객체의 메모리 주소를 리턴합니다.
반론받을 수 있는 답변 : 그럼 우리가 "hashCode"를 오버라이드 했을때에도 메모리 주소를 리턴하게 할 수 있을까요? 자바에서는 개발자가 직접 메모리에 접근할 수 있나요?


<br>

## ❓ String은 왜 문자열이 일치하면 `==` 연산의 결과값이 true로 나올까요?
* String은 두 가지 생성방식이 존재합니다.
  * 1) `new` 연산자를 이용한 방식 -> Heap 영역에 존재
  * 2) `리터럴`을 이용한 방식 -> String Constant Pool에 존재

```java
  String object = new String("literal");
  String literal = "literal";
  System.out.println(literal == object); //false
  System.out.println(literal.equals(object)); //true
```
* 모든 객체는 `new`로 생성해야하는 반면 String은 `new` 없이 `리터럴`(`""`)만으로 객체를 생성할 수 있는 특수한 클래스입니다.
* constant pool은 해시테이블 구조로 되어 있어 동일한 문자열은 해시테이블 상 같은 키를 갖게 되어 동일한 주소를 갖게 됩니다.
* `equals()`는 문자열을 비교하기 때문에 같은 문자열에 대해서는 true가 나오지만 일반 객체처럼 String 객체를 Heap에 생성시킨다면 리터럴로 저장된 String 객체와의 주소값이 다르게 설정됩니다.
* 리터럴로 선언할 시 내부적으로 `intern()` 메서드가 실행되어 주어진 문자열이 String Constant Pool에 존재하는지 검색하고 있다면 그 주소값을 반환, 없을 시 String Constant Pool에 넣고 새로운 주소값을 반환합니다.

```java
  String object = new String("literal");
  String literal = "literal";
  String intern = object.intern();

  System.out.println(literal == object); //false
  System.out.println(literal.equals(object)); //true
  System.out.println(literal == intern); //true
  System.out.println(literal.equals(intern)); //true

```

### String Constant Pool의 위치 변경
https://medium.com/@joongwon/string-%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EC%B0%B0-57af94cbb6bc


## ❓ `equals()`와 `hashCode()`를 함께 override 해줘야 하는 이유는 무엇인가요?
* `equals()`메서드를 오버라이딩하는 것은 메모리 주소가 다른 두 객체의 논리적 지위가 동일하다고 선언하는 것입니다.
* 만약 `hashCode()`를 `equals()`와 함께 재정의하지 않으면 hash 값을 사용하는 Collection(HashSet, HashMap, HashTable)을 사용할 때 중복을 판단할 때 문제가 발생합니다.
  * HashTable(다른 Hash Collection 역시 동일)은 `<key, value>` 형태로 데이터를 저장합니다. 이 때 해시 함수를 이용해 키값 기준 고유 식별값인 해시값을 만듭니다. 이 해시값을 버킷에 저장합니다.
  * 하지만 HashTable의 크기는 한정적이기 때문에 서로 다른 객체라 하더라도 같은 해시값을 가질 수 있습니다. (=> Hash Collisions; 해시충돌)
  * 이처럼 같은 해시값의 버킷 안에 다른 객체가 있는 경우 `equals()`를 사용합니다.
* if) `hashCode()`를 재정의하지 않으면
  * 같은 값 객체라도 해시 값이 다를 수 있습니다. => HashTable에서 해당 객체가 저장된 버킷을 찾을 수 없습니다.
* if) `equals()`를 재정의하지 않으면
  * `hashCode()`가 만든 해시값을 이용해 객체가 저장된 버킷을 찾을 수는 있지만 해당 객체가 자신과 같은 객체인지 값을 비교할 수 없기 때문에 null을 리턴하게 됩니다.

* https://tecoble.techcourse.co.kr/post/2020-07-29-equals-and-hashCode/


"hashCode" 를 잘못 오버라이딩하면 "HashMap" 등 hash 콜렉션의 성능이 떨어질 수가 있습니다. 어떤 케이스일 때 그럴 수 있을까요?
"HashMap"은 내부적으로 어떻게 구현되어있길래 그렇게 빨리 값을 탐색할 수 있을까요?
검색 키워드
HashMap 내부 LinkedList ("RedBlackTree" 관련한 내용도 나오면 좋습니다.)
IDE를 이용해 `HashMap` 의 구현 내용 들여다보기
꼬리질문
기존 "HashMap" 의 시간복잡도는 얼마이고, "hashCode" 를 잘못 오버라이딩 했을때의 시간복잡도는 얼마일까요?

<br>

---

<br>

# 📌 타입

## ❓ Primitive Type vs Reference Type

### Call by Ref / Call by Value

## ❓ String, StringBuilder, StringBuffer 각각의 차이에 대해 설명해주세요.

### Immutable(불변) / Mutable(가변)
* 객체가 초기화 된 이후 값이 바뀔 수 있는지 여부에 따라 구분합니다.
* Immutable(불변; 수정 불가능)
  * Int, Float, String, ...
  * 객체를 초기화한 이후에 새로운 값을 할당하면 새로운 객체가 생성되고 변수가 이를 가리키게 됩니다.
  * String의 경우 생성 후 Constant Pool에 두고 상수처럼 재사용할 수 있어 성능상의 이점이 있습니다.
  * Multi-Thread 환경에서 동기화 문제가 발생하지 않습니다. (Thread-Safe)
  * 에러가 발생하더라도 객체의 상태값이 변함 없습니다.
  * 캐시 효율을 누릴 수 있습니다.
* Mutable(가변; 수정 가능)
  * StringBuilder, StringBuffer, ArrayList, ...
  * 객체를 초기화한 이후 값을 새로 할당할 경우 기존에 생성된 객체가 수정됩니다.
  * 즉, 변수가 가리키는 메모리 주소가 변하지 않습니다.

### String
* 불변(immutable)
  * new 연산을 통해 생성된 인스턴스의 메모리 공간은 변하지 않습니다.
  * 멀티 스레드 환경에서 동기화를 신경 쓸 필요가 없습니다. (조회 연산에 장점이 있습니다.)
* GC로 제거되어야 합니다.
* 문자열 연산 시 새로 객체를 만드는 오버헤드가 발생합니다.
* 즉, 문자열 연산이 적고 조회가 많은 멀티 스레드 환경에서 적합합니다.

### StringBuilder / StringBuffer
* 공통점: 가변(mutable)
  * new 연산으로 클래스를 한 번만 만듭니다.
  * 문자열 연산 시 새로 객체를 만들지 않고 크기를 변경시킵니다.
* 차이점:
  * StringBuilder: Thread-Safe X -> synchronized 불가능(동기화를 보장하지 않습니다.)
    * 문자열 연산이 많은 멀티 스레드 환경에서 적합합니다.
  * StringBuffer: Thread-Safe O → 멀티 스레드 환경에서 사용(메서드 별로 `synchronized` 키워드가 존재해 멀티스레드 환경에서도 동기화를 지원합니다.)
    * 문자열 연산이 많은 싱글 스레드 혹은 스레드 상관 없는 환경에 적합합니다.

### ❓❓ 왜 동기화(synchronized)가 걸려있으면 느린걸까요? 싱글 스레드로 접근한다는 가정 하에선 StringBuilder와 StringBuffer의 성능이 똑같을까요?

## ❓ 제네릭이란 무엇인지 설명해주세요.
* 자바의 타입 안정성, 컴파일 과정 시 타입 체크 → 객체의 타입 안정성을 높이고 형변환의 번거로움을 줄여줌

## ❓ 오버라이딩과 오버로딩에 대해 설명해주세요. | 
오버라이딩: 상위 클래스의 메소드를 재정의, 런타임 다형성 / 
오버로딩: 같은 클래스 내에서 동일한 메소드 이름 but 매개변수 타입 & 개수 다른 것, 컴파일 다형성 |

Q. Overloading이란 무엇인지 예시와 함께 설명해주세요
자바에서 메서드를 정의할 때, 메서드의 이름과 리턴타입은 같되 그 매개변수의 갯수나 타입을 다양하게 지정할 수 있다는 것을 오버로딩이라고 합니다. 이 대표적인 예시로는 출력함수인 System.out.println이 있습니다. 출력함수에 인자로 String, int 등 여러 타입의 변수들을 넘길 수 있는 이유가 println이 오버로딩된 메서드이기 때문입니다.
Q. Overriding이란 무엇인지 예시와 함께 설명해주세요
overriding은 부모 클래스로부터 상속받은 메서드를 자식 클래스에서 재정의하는 것을 말합니다. 이 때 자식이 overriding한 메서드는 부모 클래스의 메서드와 이름, 매개변수 타입과 순서, 리턴 타입이 모두 같아야 합니다. 그리고 접근 제한이 부모랑 같거나 더 넓어야 합니다.
오버라이딩의 대표적인 예시로는 Object 클래스의 toString이 있습니다. 자바의 모든 클래스는 Object 클래스를 상속하는데, 이 때 Object 클래스에서 선언된 toString메서드를 오버라이딩 해서 활용할 수 있습니다.

## ❓ 인터페이스와 추상 클래스의 차이점에 대해 설명해주세요. | 
인터페이스: 구현 객체가 같은 동작을 하는 것을 보장, 다중 상속 가능, 인터페이스 구현 집합 간에는 관계 없을 수 있음 / 
추상 클래스: 객체의 추상적인 상위 개념으로 공통된 개념을 표현할 때 사용, 단일 상속만 가능, 추상클래스 상속하는 집합 간에는 연관관계가 있음 |

# 📌 클래스와 객체

## ❓ static 키워드에 대해 설명해주세요. | 
static 변수, static 메소드 → 정적 멤버(클래스 멤버): 객체(인스턴스)에 소속된 멤버가 아닌 클래스에 고정된 멤버, 클래스 로더가 클래스를 로딩해서 메소드 메모리 영역에 적재할 때 클래스 별로 관리, Heap이 아닌 Static 영역에 할당됨(모든 객체가 공유하여 어디서든지 참조 가능 but GC 관리 밖) |

## ❓ 접근제어자의 종류에 대해 설명해주세요. 
private(해당 클래스 내에서만 접근 가능), default(해당 패키지), protected(상속한 클래스), public(전체 영역에서 접근 가능) |


## ❓ Serializable

## ❓ 동시성 관련 예약어
https://devwithpug.github.io/java/java-thread-safe/
### Synchronized
synchronized 키워드를 통해 해당 블럭의 액세스를 동기화할 수 있다.
간단히 말해서 synchronized 가 선언된 블럭에는 동시에 하나의 스레드만 접근할 수 있다.

synchronized 를 추가함으로써 위 테스트는 100% 통과할 수 있다.

특정 스레드는 synchronized 메서드에 접근 시 블록 전체에 lock을 건다. 따라서 해당 스레드가 블럭을 빠져나가기 전까지 다른 스레드들은 동기화 처리된 블록에 접근할 수 없다. 하지만, 다른 스레드들은 아무런 작업을 하지 못하고 기다릴 수밖에 없어 자원의 낭비가 발생할 수 있다.

synchronized 로 선언된 블록 내부에 복잡한 로직이 들어간다고 생각해 보자. 스레드의 개수가 많으면 많을수록 실행 시간에 엄청난 지연이 생길 것이다. 이를 확인해 보기 위해 간단한 테스트를 해보았다.
따라서, 동시성 문제를 해결하기 위해 synchronized 키워드는 매우 간단한 해결방법이 될 수 있지만, critical section의 크기및 실행시간에 따라 성능하락 및 자원낭비가 매우 심해지게 된다.


System.out.println 메소드는 현업에서 절대 쓰지 말라고하는 메소드인데요. 그 이유가 무엇일까요?
검색 키워드
System.out.println 성능
Blocking IO
꼬리질문
이유를 찾아보셨으면, 왜 그것들이 성능을 저하시킬까요?
synchronized 키워드는 왜 현업에서 큰 성능 저하를 일으킬 수 있을까요?
Blocking IO는 왜 성능을 저하시킬 수 있을까요?
synchronized 가 Blocking IO 와 만나면 어떻게 환장의 성능하락을 만들 수 있는걸까요?
이 두 개가 만났을 때 스레드가 어떻게 동작할지, CPU 사용률은 어떻게 될지 시뮬레이션을 해보세요.

A. println 메서드는 글자를 출력하는 print 메서드와 개행을 하는 newLine기능이 실행되는데, 이들이 synchronized로 감싸져 있습니다. 그렇기 때문에 특정 시점에 하나의 스레드만이 저 블록을 실행할 수 있어서, 멀티 스레드 환경에서는 성능 저하의 요인이 될 수 있습니다.


### Volatile
JVM에서 스레드는 실행되고 있는 CPU 메모리 영역에 데이터를 캐싱 한다. (CPU Cache) 따라서 멀티 코어 프로세서에서 다수의 스레드가 변수 a를 공유하더라도 캐싱 된 시점에 따라 데이터가 다를 수 있으며, 서로 다른 코어의 스레드는 데이터 값이 불일치하는 문제가 생긴다.

임의로 데이터를 갱신해 주지 않는 이상 캐싱 된 데이터가 언제 갱신되는지 또한 정확히 알 수 없다.

이런 경우 volatile 키워드를 사용하여 CPU 메모리 영역에 캐싱 된 값이 아니라 항상 최신의 값을 가지도록 메인 메모리 영역에서 값을 참조하도록 할 수 있다. -> 즉, 동일 시점에 모든 스레드가 동일한 값을 가지도록 동기화한다.

변수 앞에 키워드를 붙여서 선언이 가능하다.

하지만 volatile 을 통해 모든 동기화 문제가 해결되는 건 아니다.

앞에서 예로 들었던 ++ 연산과 같이 원자성이 보장되지 않는 경우 동시성 문제는 동일하게 발생한다. (단지 멀티 코어에서의 모든 스레드가 캐시 없이 최신의 값을 보게 할 뿐이다!)

따라서, volatile 의 특징은 다음과 같다.

mutual exclusion(상호 배제)를 제공하지 않고도 데이터 변경의 가시성을 보장한다.
원자적 연산에서만 동기화를 보장한다.

### Atomic 클래스
앞에서 설명한 두 가지 키워드 synchronized, volatile 만으로는 동시성 문제를 깔끔하게 해결할 수 없다.

자바에서는 위 문제들을 해결하기 위해, 비-원자적 연산에서도 동기화를 빠르고 쉽게 이용하기 위한 클래스 모음을 제공한다.

java.util.concurrent.* (대표적으로 컬렉션, Wrapper 클래스 등이 있다.)


하지만, 실제 프로그래밍에서 위 테스트 코드와 같이 동시성 문제가 예상되는 곳들을 모두 파악해서 synchronzied 를 통해 동기화 설정을 할 수 있을까?

복잡한 비즈니스 로직 사이사이에 들어가 있는 비-원자적 연산을 여러개의 synchronized 블록으로 설정하는건 가능하겠지만 코드가 복잡해질 것이고, 개발자가 모든 코드에 동시성 문제를 하나하나 검토해야만 완벽하게 적용할 수 있을 것이다.

따라서 기본으로 제공하는 concurrent 패키지의 클래스들을 이용하는 것이 자바에서 동시성 문제를 해결하는 적절한 방법이라고 생각한다.

## ❓ Collection Framework

## ❓ 클래스 객체 객체지향
| 11 | 객체지향과 객체지향 5대원칙 SOLID 원칙에 대해 설명해주세요 | 
객체지향: 의존성 관리, DIP를 통한 고수준 정책과 저수준 구현 세부 사항의 분리 / 

SOLID: 
SRP, 단일책임원칙
OCP, 개방폐쇄
LSP, 리스코프 치환 : 상위 -> 하위 재정의 시 안깨져야
ISP, 인터페이스 분리 원칙: 통짜 인터페이스 
DIP 추상적인 것은 구체적인 것에 의존하지 않기, 변화하기 쉬운 것에 의존하지 않는것 -> 구 X, 변 쉬 X




GC가 무엇인지, 필요한 이유는 무엇인지, 동작방식에 대해 설명해주세요.
컬렉션 프레임워크에 대해서 설명해주세요.
제네릭에 대해서 설명해주세요.
애노테이션에 대해서 설명해주세요.
오버라이딩과 오버로딩이 무엇이며 어떤 차이가 있을까요?
인터페이스와 추상클래스의 차이점에 대해 설명해주세요.
클래스는 무엇이고 객체는 무엇인가요?
정적(static)이란 무엇인가요?
자바의 원시타입들은 무엇이 있으며 각각 몇 바이트를 차지하나요?
접근 제어자의 종류와 이에 대해 설명해주세요.
객체지향에 대해서 설명해주세요.
SOLID(객체지향 5대원칙)에 대해서 설명해주세요.
동일성(identity)와 동등성(equality)에 대해 설명해주세요. (equals(), ==)
원시타입과 참조타입의 차이에 대해 설명해주세요.
String, StringBuilder, StringBuffer 각각의 차이에 대해 설명해주세요.
Checked Exception과 Unchecked Exception에 대해 설명해주세요. 스프링 트랜잭션 추상화에서 rollback 대상은 무엇일까요?
Java8에서 추가된 기능에 대해서 설명해주세요.
try-with-resource에 대해서 설명해주세요.
강한 결합과 느슨한 결합이 무엇인지 설명해주세요.
직렬화와 역직렬화에 대해서 설명해주세요.
자바의 동시성 이슈(공유자원 접근)에 대해 설명해주세요.
Mutable 객체와 Immutable 객체의 차이점에 대해 설명해주세요.
자바에서 null을 안전하게 다루는 방법에 대해 설명해주세요.
