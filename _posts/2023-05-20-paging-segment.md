---
layout: post
title: "paging과 segmentation에 대해 알아보기"
author: "Poogle"
categories: [BackEnd]
sitemap:
changefreq: daily
priority: 1.0
comments: true
tag: [가상메모리, paging, segmentation]

---

> _참고 링크_
> 
> **Books** 
> 
> [강민철(2022). 혼자 공부하는 컴퓨터 구조 + 운영체제. 한빛미디어](http://www.yes24.com/Product/Goods/111378840)
> 
> **Youtube Videos** 
> 
> [[컴퓨터 공학 기초 강의] 38강. 페이징을 통한 가상 메모리 관리](https://www.youtube.com/watch?v=8ufliWkgqMo)
> 
> [Operating System (Complete Playlist)](https://www.youtube.com/playlist?list=PLxCzCOWd7aiGz9donHRrE9I3Mwn6XdP8p)
> 
> **Articles**
> 
> [🦕 공룡책으로 정리하는 운영체제 Ch.8](https://parksb.github.io/article/12.html#segmentation)
> 
> **Lectures**
> 
> [KOCW 운영체제 - 경성대학교 양희재](http://www.kocw.net/home/cview.do?cid=5c3c30382c7bbcf6)
> 
> **Posts**
> 
> [Segmentation(세그멘테이션)](https://matdongsane.tistory.com/31)
> 
> 
> [메모리와, 연속 메모리 할당(contiguous memory allocation)](https://matdongsane.tistory.com/29)
>

<br>

<br>

백엔드 개발자 면접을 준비하면서 자주 접하게 된 키워드 **`paging`** 과 **`segment`**. 이번 글에서는 아래 정리한 순서에 따라 **`paging`** 과 **`segment`** 에 관련된 여러 가지 주제들을 다뤄보려고 합니다.

<br>

```text
- 메모리 할당
    - 연속 메모리 할당 & 외부 단편화 문제
- 페이징을 통한 가상 메모리 관리
    - 페이징이란?
    - 페이지 테이블
    - PTBR / TLB
    - 페이징에서의 주소 변환
    - 페이지 테이블 엔트리
- 세그멘테이션을 통한 가상 메모리 관리
    - 세그멘테이션이란?
- 세그멘테이션과 페이징 비교
    - Paged Segmentation
```


<br>

<br>

# 메모리 할당

## 운영체제가 메모리를 관리하는 방법
* 먼저 메모리 할당 방법에 대해 알아보려고 합니다. 운영체제가 메모리를 관리하는 방법으로는 연속적인 방법과 비연속적인 방법이 있는데 그중 연속 메모리 할당 방법은 말 그대로 프로세스에 연속적으로 메모리 공간을 할당하는 방식을 말합니다.

<br>

## Swapping 스와핑
* 그 전에 앞서 우선 기본적인 메모리 관리 기법인 스와핑이 있습니다.

![image](https://github.com/suhyunsim/Algorithm_Practice/assets/58318786/0f5714dc-b012-424a-9d28-a4deebfd4578)

* 메모리에 모든 프로세스를 다 적재해놓으면 해당 공간이 충분하지 않기 때문에 현재 사용중이지 않은 프로세스를 임시로 보조기억장치의 스왑 영역으로 내보내고 실행할 프로세스를 적재하는 방식을 스와핑이라고 합니다. 
* 여기서 메모리로 적재하는걸 스왑인(swap-in), 보조기억장치로 빼는걸 스왑 아웃(swap-out)이라고 합니다.
* 이렇게 메모리에 스와핑 과정을 하면서 메모리를 할당하다보면 적재할 프로세스를 어떤 빈 공간에 어떻게 적재해야 할 지를 고민하게 됩니다.

<br>

## 연속 메모리 할당
* 최초 적합 first-fit: 빈공간 순서대로 검색하다가 적재할 수 있는 공간을 발견하면(최초) 그 공간에 프로세스를 배치하는 방식을 말합니다.
  * 빈 공간을 검색하는 시간이 최소화되고 할당이 빠르다는 특징이 있습니다.
* 최적 적합 best-fit: 운영체제가 비어있는 공간을 모두 검색하고 적재 가능한 가장 작은 곳으로 배치합니다.
* 최악 적합 worst-fit:  운영체제가 비어있는 공간을 모두 검색하고 적재 가능한 가장 큰 곳으로 배치합니다.
* 🤔 이렇게 어떤 방식으로든 연속적으로 메모리를 할당하다 보면 빈 공간들이 남아있곤 하는데 이러한 현상을 외부 단편화 문제라고 합니다. 
  * => 프로세스들이 실행되고 종료되길 반복하며 메모리 사이 사이에 빈 공간이 발생하는데 비어있지만 그 공간보다 큰 프로세스를 적재하기는 어렵고 결국 이는 메모리 낭비로 이어지게 됩니다.

<br>

## 외부 단편화 문제

### 해결 방법 
1) 집약(coalescing) & 압축(compaction)

![image](https://github.com/suhyunsim/Algorithm_Practice/assets/58318786/5c8ce7c5-0505-493b-948f-10974a5987e6)

* 현재 위치의 메모리에서 단편화 메모리들끼리 인접해 있는 경우 하나의 큰 메모리로 만드는 방법입니다.
* 비연속적으로 존재하는 단편화 메모리들을 메모리 재배치를 통해 하나의 연속된 큰 메모리로 만드는 방법입니다.
=> ⚠️ 단, 메모리를 재배치하면서 오버헤드가 발생할 수 있고 복잡도가 증가할 수 있습니다

2) 가상 메모리 기법 활용
* **페이징 기법(paging)**
* **세그멘테이션 기법(segmentation)**

<br>

---

<br>

# 페이징을 통한 가상 메모리 관리

## 가상메모리

![image](https://github.com/suhyunsim/Algorithm_Practice/assets/58318786/22cc2a09-15f2-42e2-9164-fa1aca13efe0)

* 가상 메모리는 프로세스가 실제 메모리의 크기와 상관없이 메모리를 이용할 수 있도록 지원하는 기술입니다. 
* 가상 메모리는 실제 메모리(RAM, main memory, first storage)와 보조 기억 장치(auxiliary storage, secondary storage)의 Swap 영역으로 구성되어있습니다. 
* OS 는 메모리 관리자(Memory Management Unit)를 통해 메모리를 관리하며 프로세스는 사용하는 메모리가 실제 메모리인지, Swap 영역인지 모릅니다. 
* Cf.) Java 에서는 Swap 영역을 잡아주지 않은 경우 OOM 이 발생할 수 있습니다. 
* Swap 영역은 실제 메모리가 아니기 때문에 지연시간이 많이 발생하며, 가급적이면 Swap 메모리를 사용하지 않도록 설계하는 것이 좋고, 만약 계속해서 사용하는 양이 증가한다면 메모리 누수를 의심해 볼 수 있습니다.

<br>

## 페이징
* 페이징은 메모리의 물리 주소 공간을 프레임 단위로 자르고, 프로세스의 논리 주소 공간을 페이지 단위로 자른 뒤 각 페이지를 프레임에 할당하는 가상 메모리 관리 기법을 의미합니다.
* 참고로 페이징도 스와핑을 사용합니다.
  ![image](https://github.com/suhyunsim/Algorithm_Practice/assets/58318786/cdbf669f-80b0-4cb9-8ee3-4533a3a78e09)

<br>

### cf.) 물리 주소와 논리 주소

![image](https://github.com/suhyunsim/Algorithm_Practice/assets/58318786/134c9af8-b385-449a-9a9a-36f7bb2dfd7e)

* 물리 주소 
  * 메모리가 사용하는 주소입니다.
  * 정보가 실제로 저장된 하드웨어상의 주소를 의미합니다.

* 논리 주소 
  * CPU와 실행 중인 프로그램이 사용하는 주소입니다. 
  * 실행중인 프로그램 각각에 부여된 0번지부터 시작되는 주소입니다.
  * 자신만을 위한 주소입니다.

<br>

## 페이지 테이블

![image](https://github.com/suhyunsim/Algorithm_Practice/assets/58318786/1f69939e-95ec-43da-8e4f-3b34cef31e82)

* 🤔 Q. 프로세스가 메모리에 불연속적으로 배치되면 CPU 입장에서 다음에 실행할 명령어 위치를 어떻게 찾을 수 있을까요?
  * ✅ 이를 확인할 수 있는 것이 페이지 테이블입니다.
* 프로세스가 실제 메모리 내의 주소인 물리 주소에 불연속적으로 배치되더라도 CPU가 바라보는 논리 주소에는 연속적으로 배치되도록 페이지 테이블을 이용합니다.
* 페이지 번호 - 프레임 번호를 짝지어 주는 이정표 
* 현재 어떤 페이지가 어떤 프레임에 할당되었는지 알 수 있습니다.

<br>

## Page Table Base Register(PTBR); 페이지 테이블 베이스 레지스터

![image](https://github.com/suhyunsim/Algorithm_Practice/assets/58318786/cd5690b8-04e1-4a5e-8753-8a77303072e9)

* 🤔 Q. 그럼 앞서 말씀드린 페이지 테이블은 어디에 적재되어 있는지 어떻게 알 수 있을까요?
  * ✅ 이를 확인할 수 있는 것이 페이지 테이블 베이스 레지스터입니다.
* 프로세스마다 각자의 프로세스 페이지 테이블이 있고, 이런 각 프로세스 페이지 테이블은 메모리에 적재되어 있고, CPU 안에 있는 페이지 테이블 베이스 레지스터(PTBR)을 확인하면 각 페이지 테이블이 어디에 적재되어있는지 알 수 있습니다.

<br>

## Translation Lookaside Buffer(TLB)

![image](https://github.com/suhyunsim/Algorithm_Practice/assets/58318786/e162a949-4493-48b6-8ce0-32f438e79c10)

* 🤔 그런데 이렇게 메모리에 페이지 테이블을 두면 CPU는 메모리에 있는 페이지 테이블을 보려고 한 번 메모리에 접근하고, 그리고 이제 알게 된 프레임을 찾으려고 또 한 번 메모리에 접근해야 하기 때문에 메모리 접근 시간이 두배가 됩니다.
  * ✅ 그래서 TLB가 등장합니다.
* TLB는 페이지 테이블의 캐시 메모리로 페이지 테이블 일부 내용(최근에 사용한 페이지 위주)을 저장하고 이 캐시에서 CPU가 찾으면 TLB 히트라고 합니다. 없으면 TLB 미스로 그 때 이제 메모리 내에 접근하게 됩니다.

<br>

## 페이징에서의 주소 변환
* 주소를 변환한다는 말은 논리 주소에서 물리 주소로 변환하는 것을 의미하는데, 페이지에서의 논리주소는 페이지 번호와 오프셋, 물리주소는 접근하려는 프레임 번호와 오프셋으로 구성되어있습니다.
* 어떤 페이지나 프레임에 접근하고 싶은지를 알고, 또 접근하려는 주소가 그 페이지 혹은 프레임으로부터 얼마나 떨어져 있는지 알 수 있으면 페이지 테이블을 참고해 주소를 변환할 수 있습니다.

### Ex. 주소 변환

![image](https://github.com/suhyunsim/Algorithm_Practice/assets/58318786/0548d10b-f9e3-4e10-b92b-1aa424c3e6b7)


<br>

## 페이지 테이블 엔트리

![image](https://github.com/suhyunsim/Algorithm_Practice/assets/58318786/ead3b056-728a-41f5-a915-604d89ce168f)

* 페이지 테이블 엔트리는 테이블 각각의 행을 의미합니다. 
* **유효 비트**: 해당 페이지 접근 가능 여부를 의미합니다. 
  * 페이지 스와핑에 따라 메모리에 적재되어 있으면 1, 보조기억장치(스왑 영역)에 있으면 0
  * 0일 때 접근하면 페이지 폴트(page fault) 예외가 발생합니다.
* **보호 비트**: 페이지 읽기(r)/쓰기(w)/실행(x) 가능 여부를 의미합니다.
  * 페이지에 접근할 권한을 제한하여 페이지를 보호하는 비트입니다.
* **참조 비트**: 접근 여부를 판단합니다.
* **수정 비트**: 수정 여부를 판단합니다. 
  * 더티 비트라고도 합니다.(dirty bit)
  * 페이지가 메모리에서 사라질 때 보조기억장치에 쓰기 작업 해야하는지 여부 판단을 위해 존재합니다.
  * CPU가 접근 X, 읽기만 한 페이지 -> 보조기억장치에 저장된 페이지와 메모리에 저장된 페이지가 동일 => 추가 작업 없이 덮어쓸 수 있습니다.
  * CPU가 쓰기 작업 수행한 페이지 -> 다른 값 => 스왑 아웃 시 변경된 값을 보조기억장치에 기록합니다.


<br>

---

<br>

# 세그멘테이션을 통한 가상 메모리 관리
* 🤔 Q. 페이징에서 하나의 프로세스를 구성하는 논리적인 의미의 코드나 데이터를 나눌 수 없을까? 라는 생각이 들 수 있습니다. (하나의 프로세스 안에서 영역 나누기)
  * ✅ 페이징에서 유저의 관점, 인간의 관점에서 하나의 프로세스를 구성하는 논리적인 내용을 기반으로 프로세스를 세그먼트로 나눈 것을 **세그멘테이션**이라고 합니다.

## 세그멘테이션이란?
* 여기서 세그멘테이션은 세그먼트의 집합을 의미합니다.
* 세그먼트 논리 단위 예시 
  * main program 
  * procedure 
  * function 
  * method 
  * object 
  * stack 
  * local variable 
  * global variable…
* 보시다시피 세그먼트 논리 단위는 이렇게 다양한 것들이 될 수 있는데요, 그렇기 때문에 세그먼트들은 각 크기가 일정하지 않습니다.

<br>

---

<br>

# 세그멘테이션과 페이징 비교

![image](https://github.com/suhyunsim/Algorithm_Practice/assets/58318786/3504da55-b4d0-4b94-bbcc-ef2ed229b170)


### Paged Segmentation; Segment + Paging 
* 세그먼트와 페이징 두 방식의 장점만을 가져온 방법입니다.
1) 프로세스를 처음에 세그먼트 단위로 자릅니다.(의미있는 단위로 자르면 보호와 공유에 이점)
2) 외부 단편화 발생을 막기 위해 잘라진 세그먼트를 다시 일정 간격인 페이지 단위로 자르는 페이징 방법을 활용합니다.
* ✅ => 메모리 적재 시 페이징의 일정 단위로 다시 잘렸기 때문에 외부 단편화 X, but 속도 문제 O
