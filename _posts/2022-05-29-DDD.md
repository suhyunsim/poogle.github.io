---
layout: post
title: "DDD와 MSA 기초(1)"
author: "Poogle"
categories: [BackEnd]
sitemap:
  changefreq: daily
  priority: 1.0
comments: true
tag: [DIP, DDD]

---

DDD와 MSA에 대해 여러 시리즈로 정리합니다.
이번 편에서는요,

```text
- 도메인
- 도메인 모델
- DIP
- 도메인 영역의 주요 구성요소
  - ENTITY
  - VALUE
  - AGGREGATE
  - REPOSITORY
  - DOMAIN SERVICE    
```
에 대해 다룹니다.

> 참고: 도서 [DDD START! 도메인 주도 설계 구현과 핵심 개념 익히기](http://www.yes24.com/Product/Goods/27750871)

<br>

# 도메인

<div style="text-align: center;"><img src="https://user-images.githubusercontent.com/58318786/170859081-0be3e7a4-bf09-4ea8-883d-499902772c0d.jpeg" width="70%" height="70%"/></div>

개발자 입장에서 구현해야 할 소프트웨어 대상, 소프트웨어로 해결하고자 하는 문제 영역은 도메인(domain)에 해당합니다.
* 도메인은 여러 하위 도메인으로 구성될 수 있지만 모든 도메인마다 고정된 하위 도메인이 존재하는 것은 아닙니다.
각 하위 도메인이 다루는 영역은 서로 다르기 때문에 어러 하위 도메인을 하나의 다이어그램에 모델링하면 안됩니다. (ex. 카탈로그와 배송 도메인 모델을 구분하지 않고 하나의 다이어그램에 함께 표시하면 -> 카탈로그의 상품과 배송의 상품 의미를 함께 제공하게 되어 이해에 방해가 됨)
모델의 각 구성요소는 특정 도메인을 한정할 때 비로소 의미가 완전해지기 때문에, 각 하위 도메인마다 별도로 모델을 만들어야 합니다.
* 또 소프트웨어가 도메인의 모든 기능을 제공하지는 않습니다.(자체 시스템 / 외부) 하위 도메인을 어떻게 구성할지 여부는 상황에 따라 달라집니다.

<br>

# 도메인 모델
<div style="text-align: center;"><img src="https://user-images.githubusercontent.com/58318786/170864779-87aea117-78cb-4b14-920a-93012ae5efa4.jpeg" width=70% height=70%/></div>

도메인 모델은 아키텍처상의 도메인 계층을 객체 지향 기법으로 구현하는 패턴으로, 도메인 모델을 사용하면 여러 관계자들이 동일한 모습으로 도메인을 이해하고 도메인 지식을 공유할 수 있는데, 이런 도메인 모델은 객체 모델이나 상태 다이어그램 등을 사용해서 모델링할 수 있습니다.
도메인 자체를 이해하기 위한 개념 모델로, 구현 기술에 맞는 구현 모델이 따로 필요합니다.
<br>
계층 구조는 그 특성상 상위 계층에서 하위 계층으로의 의존만 존재하고 하위 계층은 상위 계층에 의존하지 않습니다. 또한 엄격하게 적용하면 상위 계층은 바로 아래의 계층에만 의존을 가져야 하지만 구현의 편리함을 위해 유연하게 적용하기도 합니다.
(ex. 응용 계층이 도메인 계층에도 의존하지만 외부 시스템의 연동을 위해 더 아래 계층인 인프라 계층에 의존하기도 함)
<br>
그런데 이렇게 응용 계층이 인프라 계층에 의존하게 되면 '테스트 어려움'과 '기능 확장의 어려움' 이라는 두 가지 문제가 발생할 수 있는데 이는 DIP를 적용해서 해결할 수 있습니다.

<br>

# DIP
### ex.
<div style="text-align: center;"><img src="https://user-images.githubusercontent.com/58318786/170868978-48bb5917-b0b0-4646-bf03-55280c49360b.jpeg" width=70% height=70%/></div>

* `가격 할인 계산`이라는 `고수준 모듈`은 의미있는 단일 기능을 제공하는 모듈로 이 기능을 구현하려면 여러 하위 기능(고객 정보 구하기, 룰을 이용해 할인 금액 구하기)이 필요합니다.
* `저수준 모듈`은 하위 기능을 실제로 구현한 것입니다. 고수준 모듈이 제대로 동작하려면 저수준 모듈을 사용해야 하는데 이렇게 되면 앞서 언급한 두 문제가 발생합니다.

<div style="text-align: center;"><img src="https://user-images.githubusercontent.com/58318786/170868908-bdc1ee33-bd57-4918-8fc7-8b967cf74628.png" width=60% height=60%/></div>

* DIP는 이를 해결하기 위해 저수준 모듈이 고수준 모듈에 의존하도록 변경합니다. 이를 위해서는 `추상화한 인터페이스`를 활용합니다.
  * `CalculateDiscountService`는 `Drools`에 의존하는 코드를 포함하고 있지 않으며 `RuleDiscounter`가 룰을 적용한다는 것만 압니다. 실제 `RuleDiscounter`의 구현 객체는 생성자를 통해서 전달받습니다.
  * 룰 적용을 구현한 클래스는 `RuleDiscounter`인터페이스를 상속받아 구현합니다.
  * 룰을 이용한 할인 금액 계산은 고수준 모듈의 개념이므로 `RuleDiscounter`인터페이스는 고수준 모듈에 속합니다.
  * `DroolsRuleDiscounter`는 고수준의 하위 기능을 구현한 것이므로 저수준 모듈에 속합니다.
* 고수준 모듈이 저수준 모듈을 사용하려면 고수준 모듈이 저수준 모듈에 의존해야 하는데, 반대로 저수준 모듈이 고수준 모듈에 의존한다고 해서 이를 `DIP(Dependency Inversion Principle, 의존 역전 원칙)`이라고 부릅니다.
* 구현을 추상화한 인터페이스에 의존하면서, 구현 기술을 변경하더라도 사용할 저수준 구현 객체를 생성하는 부분의 코드만 변경하변 됩니다.
* 또한 의존 주입을 지원하는 스프링과 같은 프레임워크를 사용하면 설정 코들르 수정해서 쉽게 구현체를 변경할 수 있습니다.
* 테스트 역시 고수준 모듈이 저수준 모듈에 직접 의존했다면, 저수준 모듈이 만들어지기 전까지 테스트를 할 수 없었겠지만 인터페이스를 사용함에 따라 대용 객체를 사용해서 테스트를 진행할 수 있습니다. 즉 실제 구현 클래스가 없어도 테스트를 작성할 수 있습니다.
* DIP를 적용할 때 하위 기능을 추상화한 인터페이스는 저수준 모듈 관점이 아닌 고수준 모듈인 도메인 관점에서 도출해야 합니다.

<br>

# DIP와 아키텍처
<div style="text-align: center;"><img src="https://user-images.githubusercontent.com/58318786/170870728-b5751170-0aba-41cc-9ef9-0f0e4c0ea73b.jpeg" width=70% height=70%/></div>

인프라 영역은 구현 기술을 다루는 `저수준 모듈`이고 응용 영역과 도메인 영역은 `고수준 모듈`입니다. 아키텍처 수준에서 DIP를 적용하면 인프라 영역이 응용 영역과 도메인 영역에 의존(상속)하는 구조가 됩니다.
즉, 인프라 영역에 위치한 클래스가 도메인이나 응용 영역에 정의한 인터페이스를 상속받아 구현하는 구조가 되므로 도메인과 응용 영역에 대한 영향을 최소화하면서 구현 기술을 변경할 수 있습니다. 

<div style="text-align: center;"><img src="https://user-images.githubusercontent.com/58318786/170871567-0017f226-a13e-4f45-bbfd-918533c33c35.png"/></div>

<br>

# 도메인 영역의 주요 구성요소
## 엔티티(Entity)
* 도메인 모델의 데이터를 포함하여 해당 데이터와 관련된 기능을 함께 제공합니다.
* 식별자를 갖는다는 가장 큰 특징이 있으며, 식별자는 엔티티 객체마다 고유해서 각 엔티티는 서로 다른 식별자를 갖습니다.
* 식별자는 엔티티 생성 -> 속성 변경 -> 삭제할 때까지 유지된다. 바뀌지 않고 고유하기 때문에 두 엔티티 객체의 식별자가 같으면 두 엔티티는 같다고 판단할 수 있습니다.

<br>

## 밸류 타입(Value)
* 고유의 식별자를 갖지 않는 객체로 주로 개념적인 하나의 도메인 객체의 속성을 표현할 때 사용됩니다. 또한 다른 밸류 타입의 속성으로도 사용될 수 있습니다.
```java
public class ShippingInfo {
    
    //받는 사람
    private String receiverName;
    private String receiverPhoneNumber;
    
    //주소
    private String shippingAddress1;
    private String shippingAddress2;
    private String shippingZipCode;
    
}
```
* 받는 사람과 주소 필드들은 각각 개념적으로 완전한 하나를 표현하고 있다. 따라서 밸류타입 Receiver와 Address를 만들어서 개념적으로 완전한 하나를 보다 명확하게 표현할 수 있다.

```java
public class Receiver {
  private String name;
  private String phoneNumber;

  //생성자, getter, setter...
}
```
```java
public class Address {
  private String address1;
  private String address2;
  private String zipcode;
  //생성자, getter, setter...
}
```

```java
//Value 타입 이용
public class ShippingInfo {
  private Receiver receiver;
  private Address address;
  //생성자, getter, setter...
}
```

* 밸류 타입은 의미를 명확하게 표현하기 위해 사용합니다.
* 또한 밸류 타입을 위한 기능을 추가할 수 있습니다.
* 밸류 객체의 데이터를 변경할 때는 기존 데이터를 변경하기보다는 변경한 데이터를 갖는 새로운 밸류 객체를 생성하는 방식을 선호합니다.
* 밸류 타입을 불변(immutable)으로 구현하는 가장 중요한 이유는 보다 안전한 코드를 작성할 수 있는데에 있습니다. 불변 객체는 참조 투명성과 스레드에 안전한 특징을 갖고 있습니다.
* 두 밸류 객체가 같은지 비교할 때는 모든 속성이 같은지 비교해야 합니다.

### 엔티티 식별자와 밸류 타입
엔티티 식별자의 실제 데이터는 문자열로 구성된 경우가 많은데 Money가 단순 숫자가 아닌 도메인의 '돈'을 의미하는 것처럼 식별자가 도메인에서 특별한 의미를 지니도록 하기 위해 식별자를 위한 밸류타입을 사용할 수도 있습니다.
```java
public class Order {
    //OrderNo 타입 자체로 id가 주문번호임을 알 수 있음
    private OrderNo id;
    // ...
}
```
* OrderNo 대신 String -> id라는 이름 만으로는 주문번호인지 알 수 없음 => 필드이름이 id가 아닌 OrderNo가 됨
* String 대신 OrderNo 타입을 식별자로 => 타입 자체로 알 수 있음

<br>

## 애그리거트(Aggregate)
* 관련된 엔티티와 밸류 객체를 개념적으로 하나로 묶은 것입니다. 도메인 모델에서 전체 구조를 이해하는 데 도움이 됩니다.
* 애그리거트를 사용하면 개별 객체가 아닌 관련 객체를 묶어서 객체 군집 단위로 모델을 바라볼 수 있게 되며 애그리거트 간의 관계로 도메인 모델을 이해하고 구현할 수 있게 됩니다.
* 루트 엔티티는 애그리거트에 속해 있는 엔티티와 밸류 객체를 이용해서 애그리거트가 구현해야 할 기능을 제공합니다.
<div style="text-align: center;"><img src="https://user-images.githubusercontent.com/58318786/170872103-1f928f31-773b-49be-afb7-3ac1d05ec451.jpeg" width=50% height=50%/></div>

* ex. 주문과 관련된 Order 엔티티, OrderLine 밸류, Orderer 밸류 객체를 주문 애그리거트로 묶을 수 있습니다.

## 리포지터리(Repository)
* 도메인 모델의 영속성을 처리합니다.
* 도메인 모델 관점에서 Repository Interface는 도메인 객체를 영속화하는데 필요한 기능을 추상화한 것으로 고수준 모델에 속합니다. 이를 이용해서 구현한 클래스는 저수준 모델로 인프라 영역에 속하게 됩니다.
### 응용 서비스와 리포지터리
* 응용 서비스는 필요한 도메인 객체를 구하거나 저장할 때 리포지터리를 사용합니다.
* 응용 서비스는 트랜잭션을 관리하는데, 트랜잭션 처리는 리포지터리 구현 기술에 영향을 받습니다.
* 리포지터리는 응용 서비스가 필요로 하는 메서드를 제공하는데 가장 기본이 되는 것이 애그리거트를 저장하는 메서드와 애그리거트 루트 식별자로 애그리거트를 조회하는 메서드입니다.
```java
public interface SomeRepository {
    void save(Some some);
    Some findById(SomeId id);
}
```
## 도메인 서비스(Domain Service)
* 특정 엔티티에 속하지 않은 도메인 로직을 제공합니다.