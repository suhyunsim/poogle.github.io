---
layout: post
title: "운영체제 면접 질문 모음"
author: "Poogle"
categories: [BackEnd]
sitemap:
changefreq: daily
priority: 1.0
comments: true
tag: []

---

> 참고 링크
> 
> [Backend-Interview-Question](https://github.com/ksundong/backend-interview-question)
> 
> [[기술 면접 준비 - 1일차] 운영체제](https://imbf.github.io/interview/2020/11/26/NAVER-Interview-Preparation-1.html)
> 
> [youtube - [10분 테코톡] 🎲 와일더의 Mutex vs Semaphore](https://www.youtube.com/watch?v=oazGbhBCOfU)
> 
> [책 - 실습과 그림으로 배우는 리눅스 구조](http://www.yes24.com/Product/Goods/69660412)
> 

<br>

<br>

# 📌 Computer System
## ❓ 컴퓨터 시스템의 동작에 따른 하드웨어 구조에 대해 설명해주세요.

![컴퓨터 시스템의 동작방식과 하드웨어 구조](https://user-images.githubusercontent.com/58318786/226808645-44d7e4a1-1e5c-401a-87d6-18c9078d3f2e.jpeg)

## ❓ 프로그램의 종류에 대해 설명해주세요. 

![프로그램 종류](https://user-images.githubusercontent.com/58318786/226812236-a58e532d-5e00-4bc2-bc40-2402fdb2ca8c.jpeg)

* 애플리케이션: 사용자가 직접 사용하는 프로그램을 의미합니다.
* 미들웨어: 여러 가지 어플리케이션이 공통으로 사용하는 처리를 묶어서 애플리케이션의 실행을 도와줍니다.
* OS(운영체제): 하드웨어를 직접 조작하여 애플리케이션이나 미들웨어의 실행에 필요한 기능을 제공합니다.
  * OS는 여러 가지 프로그램을 프로세스라는 단위로 실행합니다.
  * 프로세스는 디바이스 드라이버를 통해 디바이스에 접근하고 종류가 같은 디바이스는 같은 인터페이스로 조작합니다.
  * OS는 프로세스가 직접 하드웨어에 접근하는 것을 차단하기 위해 CPU의 `커널 모드`로 동작할 때만 디바이스에 접근할 수 있도록 합니다.
  * **디바이스 드라이버**는 `커널 모드`로 동작하고 **프로세스**는 `사용자 모드`로 동작합니다.

<br>

---

<br>

# 📌 사용자 모드, 커널 모드
## ❓ 시스템 콜은 무엇이고 종류는 무엇이 있을까요?
* 프로세스는 프로세스의 생성이나 하드웨어의 조작 등 커널의 도움이 필요할 경우 시스템 콜을 통해 커널에 처리를 요청합니다.
* 종류
  * 프로세스 생성, 삭제
  * 메모리 확보, 해제
  * 프로세스 간 통신 IPC
  * 네트워크
  * 파일시스템 다루기
  * 파일 다루기(디바이스 접근)

### CPU 모드 변경

![CPU 모드 변경](https://user-images.githubusercontent.com/58318786/226821781-dc94a4e9-b19c-4e6e-8448-676ac3e182f8.jpeg)

* 프로세스는 사용자 모드로 실행되다가 커널에 처리를 요청할 때 시스템 콜을 호출합니다.
* CPU에서는 인터럽트 이벤트가 발생하고 CPU가 사용자 모드에서 커널 모드로 변경되며 요청한 내용을 처리하기 위해 커널이 동작합니다.
* 요청한 내용 처리가 끝내면 커널 내의 시스템 콜 처리가 종료되고 다시 사용자 모드로 돌아가 프로세스의 동작을 계속 진행합니다.

<br>

---

<br>


# 📌 Process & Thread

## ❓ Core란 무엇인가요?
* CPU 기본 계산 단위를 의미합니다.

## ❓ Process란 무엇이며 어떤 메모리 구조로 되어있나요?
* 실행중인 프로그램을 의미하고 보조저장장치로부터 메모리에 적재되어 CPU의 할당을 받을 수 있는 단위를 의미합니다.
* 메모리 구조
  * 실행 코드가 저장되는 `text` 영역
  * 전역 변수 등을 수록하는 `data` 영역
  * 프로세스 실행 중에 동적으로 할당되는 메모리인 `heap` 영역
  * 함수의 매개변수, 복귀 주소와 로컬 변수와 같은 임시 자료를 갖는 `stack` 영역
* text, data, heap, stack 영역을 포함하는 구조의 메모리를 가지고 이들은 프로세스 간 공유가 되지 않습니다.

## ❓ 프로세스는 운영체제에 어떻게 저장되나요?
* PCB(Process Control Block)
  * 특정 프로세스에 대한 중요한 정보를 저장하고 있는 운영체제의 자료구조인 PCB를 통해 저장됩니다.
  * PID, Process Status, PC(프로세스 실행을 위한 다음 명령의 주소를 표시), CPU 레지스터, CPU 스케줄링 정보 등으로 구성되어 있습니다.

## ❓ 프로세스 동기화란 무엇이며 관련된 문제 상황에는 무엇이 있을까요?
* 다중 프로세스 환경에서 자원 등에 한 프로세스만이 접근가능하도록 하는 것을 의미합니다.
* 프로세스 동기화를 하지 않으면 동시에 공유 자원에 접근할 수 있어 데이터의 일관성이 깨질 수 있습니다.
* **Race Condition(경쟁 상태)**
  * 여러 프로세스나 스레드가 동기화 메커니즘 없이 자원에 접근하려는 상황을 의미합니다.
  * 공유된 자원에 대한 접근 순서에 따라 실행 결과가 달라질 수 있는 상황을 의미합니다.
* **Critical Section(임계 구역)**
  * 여러 스레드가 동시에 접근해서는 안되는 공유자원에 접근하는 코드 블럭을 의미합니다.
  * 한 임계구역에 하나의 스레드 혹은 프로세스만 접근이 가능해야 합니다.
  * 임계 구역에 접근하는 것을 제어하기 위해 `세마포어`, `뮤텍스`와 같은 매커니즘을 사용합니다.

## ❓ 임계 구역 문제를 해결하기 위한 조건은 무엇인가요?
* `상호 배제(Mutual Exclusion)`: 한 프로세스가 임계구역에서 동작중이면 다른 프로세스는 접근할 수 없습니다.
* `진행(Progress)`: 임계구역에서 작업중인 프로세스가 없다면 입계구역으로 진입하려는 프로세스를 적절히 선택해서 진입할 수 있도록 합니다.
* `유한 대기(Bounded Waiting)`: 한 프로세스가 임계영역으로 진입을 요청한 후 다른 프로세스는 진입이 유한한 횟수로 제한되어야 합니다. (기아상태 방지)

## ❓ 임계 구역 문제를 해결하기 위한 기법에는 무엇이 있나요?
* `Lock`: 하드웨어 기반 해결책
  * 임계 구역에 진입하기전에 Lock을 얻고, 임계 구역에서 빠져 나올 때 Lock을 방출함으로써 프로세스간에 동기화를 유지합니다.
* `Semaphores`: 소프트웨어 상에서 임계 구역 문제를 해결하기 위한 동기화 도구입니다.
  * 두 개의 프로세스 사이에서 동기화를 유지할 수 있는 이진 세마포
  * 프로세스 세 개 이상의 프로세스 사이에서 동기화를 유지할 수 있는 카운팅 세마포
* `모니터`: 고급 언어의 설계 구조물
  * 개발자의 코드를 상호배제 하게끔 만든 추상화된 데이터 형태

<br>

## ❓ Thread란 무엇인지 설명해주세요.
* 프로세스의 CPU 이용을 위한 기본 단위, 프로세스 내에서 실행되는 실행 흐름의 단위를 의미합니다.
* 스레드는 프로세스 내에서 Stack만 할당받으며 Code, Data, Heap 영역을 같은 프로세스 내의 스레드 간에 공유합니다.
* 프로세스의 주소 공간이나 자원등을 공유해 프로세스를 여러 실행 흐름으로 실행시킬 수 있습니다.

## ❓ 스택을 스레드마다 독립적으로 할당하는 이유는 무엇일까요?
* 스택은 함수의 인자, 복귀 주소, 지역 변수 등을 저장하기 위해 사용되는 메모리 공간이므로 스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것을 의미합니다.
* 이는 독립적인 실행 흐름이 추가되는 것이기 때문에 프로세스를 여러 실행 흐름으로 만들기 위해서는 스레드에 스택을 독립적으로 할당해야 합니다.

## ❓ PC Register를 스레드마다 독립적으로 할당하는 이유
* PC 값은 다음에 실행될 명령어의 주소를 나타내므로 프로세스의 개별 실행 흐름인 스레드가 독립적으로 명령어들을 실행하기 위해선 스레드에 PC 레지스터가 독립적으로 할당되어야 합니다.

## ❓ Multi-Thread Programming은 무엇인가요?
* 멀티 스레드 프로그래밍은 하나의 프로세스에서 여러 개의 스레드를 만들어 자원의 생성과 관리의 중복을 최소화하는 것을 말합니다. 
* 👍 장점
  * 멀티 프로세스에 비해 메모리 자원소모가 줄어듭니다.
  * 힙 영역을 통해서 스레드간 통신이 가능해서 프로세스간 통신보다 간단합니다.
  * 스레드의 컨텍스트 스위칭은 프로세스의 컨텍스트 스위칭보다 빠릅니다.
* 👎 단점
  * 힙 영역에 있는 자원을 사용할 때는 경쟁 조건이 발생할 수 있으므로 동기화를 해야 합니다.
  * 동기화를 위해서 락을 과도하게 사용하면 성능이 저하될 수 있습니다.
  * 하나의 스레드가 비정상적으로 동작하면 다른 스레드도 종료될 수 있습니다.

## ❓ Thread-Safe는 무엇을 의미하나요?
* 두 개 이상의 스레드가 race condition에 들어가거나 같은 객체에 동시에 접근해도 연산결과의 정합성이 보장될 수 있게끔 메모리 가시성이 확보된 상태를 의미합니다.
* Java에서 Thread-Safe 설계 방법
  * `java.util.concurrent` 패키지 하위의 클래스를 사용합니다.
  * 인스턴스 변수를 두지 않습니다.
  * Singleton 패턴을 사용합니다.(이 때, 일반적으로 구현하는 Singleton Pattern은 Thread-safe 하지 않음)
  * 동기화(`synchronized`) 블럭에서 연산을 수행합니다.

<br>

## ❓ Process와 Thread의 차이를 설명해주세요.
* 프로세스는 운영체제로부터 자원을 할당받지만, 스레드는 프로세스로부터 자원을 할당받고 프로세스의 코드/데이터/힙영역을 공유하기 때문에 좀 더 효율적으로 통신할 수 있습니다.
* 컨텍스트 스위칭도 캐시 메모리를 비우지 않아도 되는 스레드쪽이 빠릅니다.
* 스레드는 자원 공유로 인해 문제가 발생할 수 있으니 이를 염두에 둔 프로그래밍을 해야 합니다.

## ❓ Multi-Process와 Multi-Thread의 차이를 설명해주세요,
* 멀티 스레드와 멀티 프로세스의 차이는 여러 실행흐름을 프로세스를 통해서 만드는지 아니면 프로세스 내의 스레드를 통해서 만드는지에 있습니다.
* 동시에 여러 작업을 수행한다는 점에서 목적은 같지만, 서로 장단점이 존재합니다.
* 멀티 프로세스 - 👍 장점
  * 여러 프로세스 중 하나의 프로세스에 문제가 발생한다면 해당 프로세스에서만 문제를 해결하면 되기 때문에 멀티 스레드에서 비해서 상대적으로 안정적입니다.
* 멀티 프로세스 - 👎 단점
  * 프로세스 간에 공유 되어지는 메모리가 없기 때문에 프로세스 간의 통신을 위해서 통신 기법이 필요합니다.
  * Context Switching 이나 자식 프로세스 생성 시 많은 오버헤드가 발생하기 떄문에 여러 프로세스가 존재하는 경우 프로그램의 수행 시간이 전체적으로 시간이 느려질 수 있습니다.
* 멀티 스레드 - 👍 장점
  * 자식 프로세스를 생성하거나 Context Switching(CPU에서 여러 프로세스를 돌아가면서 작업을 처리하는 과정)과 같은 오버헤드가 많이 발생하는 작업이 없어짐으로 시스템의 처리량이 증가합니다.
* 멀티 스레드 - 👎 단점
  * 프로세스의 Code, Heap, Data 메모리 영역을 공유하기 때문에 동기화 문제가 발생할 수 있습니다.
  * 하나의 스레드에서 문제가 발생하면 전체 프로세스가 영향을 받을 수 있습니다.

## ❓ Multi-Process, Multi-Thread는 언제 사용할까요?
* CPU가 처리해야하는 task의 특성이 크기가 크지 않으면서 개수가 많을 경우나 실시간성이 중요한 웹과 같은 경우 => 멀티 스레드
* CPU가 처리해야하는 task의 특성이 크기가 크면서 개수가 적은 경우나 실시간성이 중요하지 않은 일괄 처리 같은 경우 => 멀티 프로세스

## ❓ Context Switching 컨텍스트 스위칭에 대해 설명해주세요.
![IMG_85CCBC5F8C66-1](https://user-images.githubusercontent.com/58318786/226825659-37f4552f-9d4c-485f-b1e1-f359fbdfa669.jpeg)

* 논리 CPU 상에서 동작하는 프로세스가 바뀌는 것을 의미합니다.
* 프로세스가 어떤 프로그램을 수행중이더라도 타임 슬라이스를 모두 소비하면 발생합니다.
* 한 Task가 끝날 때까지 기다리는 것이 아니라 여러 작업을 번갈아가며 실행해서 동시에 처리될 수 있도록 하는 방법입니다.
* 인터럽트가 발생하면 현재 프로세스의 상태를 PCB에 저장하고 새로운 프로세스의 상태를 레지스터에 저장하는 방식으로 동작합니다.
  * 이 때, CPU는 아무런 일을 하지 않으므로 잦은 컨텍스트 스위칭은 성능저하를 일으킬 수 있습니다.
* 스레드는 캐시메모리나 PCB에 저장해야하는 내용이 적고, 비워야 하는 내용도 적기때문에 상대적으로 더 빠른 컨텍스트 스위칭이 일어날 수 있습니다.

<br>

# 📌 스케줄러 (Scheduler)
## ❓ 프로세스 스케줄러란?
* 멀티 프로세스 기법을 사용하는 시스템은 프로세스의 실행 순서를 스케줄링 해야만 합니다. -> 프로세스의 실행 순서를 스케줄링하는 도구를 "프로세스 스케줄러"라고 합니다.
* Job Scheduler: 프로그램이 저장되어 있는 디스크에서 -> 메모리로 프로세스 스케줄링을 담당합니다.
* CPU Scheduler: CPU와 <-> 메모리 사이의 스케줄링을 담당합니다.
  * Ready Queue에 있는 프로세스들을 스케줄링하는 스케줄러
  * FCFS(First Come First Serve): 먼저 Ready Queue에 들어온 프로세스를 먼저 처리하는 스케쥴링 기법
  * SJF(Shortest Job First): CPU Burst Time이 짧은 프로세스를 먼저 처리하는 스케줄링 기법
  * SRT(Shortest Remaining Time First): SJF 기법 기반으로 새로운 프로세스가 도착할 때마다 새로운 스케줄링이 이루어져 가장 짧은 프로세스를 먼저 처리하는 기법
  * Priority Scheduling: 프로세스에 우선순위를 부여하여 우선순위가 높은 프로세스를 먼저 처리하는 기법
  * Round Robin: 프로세스에 CPU 할당 시간을 정해 놓아 CPU를 할당하는 방법
* Swapper: 메모리에서 -> 디스크로 프로세스 스케줄링을 담당합니다.

---

<br>

# 📌 교착상태(Deadlock), 기아상태(Starvation)
## ❓ 교착상태(Deadlock)란?
![IMG_6CC308928F87-1](https://user-images.githubusercontent.com/58318786/227782932-33ec1315-adef-44c3-b3d9-a2d60709a4a4.jpeg)
* 서로 다른 프로세스가 서로 점유하고 있는 자원의 반납을 대기하고 있는 상태를 의미합니다.
* 발생조건(4가지 모두 만족해야 합니다.)
  * **상호 배제**: 한 번에 한 프로세스만 해당 자원을 사용할 수 있어야 합니다.
  * **점유 대기**: 할당된 자원을 가진 상태에서 다른 자원을 기다립니다.
  * **비선점**: 다른 프로세스가 자원의 사용을 끝낼 때 까지 자원을 뺏을 수 없습니다.
  * **순환대기**: 각 프로세스가 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있습니다.
* 해결방법
  * 예방: 4가지 조건 중 하나라도 만족되지 않도록 합니다.
  * 회피: 알고리즘을 데드락이 발생하지 않도록 합니다.
  * 회복: 교착상태가 발생할 때, 해결합니다.
  * 무시: 회복과정의 성능저하가 심하다면 그냥 무시합니다.
  
## ❓ 기아상태(Starvation)란?
* 여러 프로세스가 부족한 자원을 점유하기 위해 경쟁할 때, 특정 프로세스가 영원히 자원 할당이 되지 않는 경우를 의미합니다.
* 우선순위를 변경(우선순위를 수시로 변경하거나, 오래 기다린 프로세스의 우선순위를 높여주거나, Queue를 사용)합니다.

---

<br>

# 📌 Semaphore, Mutex, SpinLock
## ❓ Semaphore(세마포어)란?
* 여러 개의 프로세스가 접근 가능한 공유자원을 관리하는 방식입니다.
* 세마포어 변수를 통해 wait/signal을 관리합니다.
* 세마포어는 뮤텍스가 될 수 있습니다.(접근 가능한 공유 자원의 수가 1개일 때 이진 세마포어로 뮤텍스처럼 사용할 수 있습니다.)
* 세마포어는 다른 프로세스가 세마포어를 해제할 수 있습니다.(Lock을 걸지 않은 스레드도 signal을 보내 lock 해제 가능합니다.)

## ❓ Mutex(뮤텍스; Mutual + Exclusion)란?
- 여러 스레드를 사용하는 환경에서 자원에 대한 접근을 강제하기 위한 동기화 매커니즘입니다.
* 한 번에 한 개의 프로세스만 접근 가능하도록 관리하는 방식입니다.
  * 공유자원을 사용 중인 스레드 있을 떄 다른 스레드가 공유자원에 접근하면 락 걸어서 blocking 한 후 대기큐에 대기합니다.
* 뮤텍스는 세마포어가 될 수 없습니다.
* 뮤텍스는 락을 획득한 프로세스만 락을 반환할 수 있습니다.

## ❓ SpinLock(스핀락)이란?
- Busy-waiting 하며 대기 큐를 갖지 않습니다.
- 컨텍스트 스위칭 시간이 더 짧거나 멀티 코어 프로세스일 때 사용합니다.
- Mutex-nonblocking 모델입니다.

---

<br>

# 📌 Sync, Async
## ❓ 동기(Sync)와 비동기(Async)의 차이(블로킹, 넌블로킹) / 장단점에 대해 설명해보세요.
* 동기는 요청과 동시에 결과가 일어나는 경우를 동기라고 표현, 비동기는 요청과 결과가 동시에 일어나지 않는 경우를 비동기라고 표현합니다.
* **동기 방식(Sync)**
  * 메서드 리턴과 결과를 전달받는 시간이 일치하는 명령 실행 방식입니다.
  * 동기 방식은 한 함수가 끝나는 시간과 바로 다음의 함수가 시작하는 시간이 같습니다.
* **비동기 방식(Async)**
  * 여러 개의 처리가 함께 실행되는 방식입니다.
  * 동기 방식에 비해 단위시간 당 많은 작업을 처리할 수 있습니다.
  * 단, CPU나 메모리를 많이 사용하는 작업을 비동기로 처리하게 되면 과부하가 걸릴 수 있고 프로그램의 복잡도도 증가하게 됩니다.
* 블로킹/논블로킹은 동기/비동기와는 다른 관점으로, 내가 직접 제어할 수 없는 대상(IO/멀티스레드)을 상대하는 방법에 대한 분류를 의미합니다.
* 요청에 대한 응답을 얻기 까지 다른 실행 흐름들이 기다리는 것을 blocking이라고 하고, 다른 실행 흐름이 요청에 대한 응답을 대기하지 않고 자유롭게 CPU나 메모리 등을 이용하는 상황을 non-blocking 이라고 합니다.
* **블로킹 방식(Blocking)**
  * 대상의 작업이 끝날 때 까지 제어권을 대상이 가지고 있는 것을 의미합니다.
* **논블로킹 방식(Non-Blocking)**
  * 대상의 작업 완료여부와 상관없이 새로운 작업을 수행합니다.
* 동기 논블로킹은 계속해서 polling을 수행하기 때문에 컨텍스트 스위칭이 지속적으로 발생해 지연이 발생합니다.

---

<br>

# 📌 Memory
## ❓ Swapping 이란 무엇인가요?
* 메모리의 관리를 위해 사용되는 기법입니다.
* CPU 할당 시간이 끝난 프로세스의 메모리를 보조기억장치(하드디스크)로 내보내고 다른 프로세스를 메모리로 불러 들이는 것을 의미합니다.
* swap-in: 주 기억장치(RAM)으로 불러오는 과정
* swap-out: 보조 기억장치로 내보내는 과정
* swap에는 큰 디스크 전송시간이 필요하기 때문에 현재에는 메모리 공간이 부족할 때 Swapping이 시작됩니다.

## ❓ Swapping을 하면서 발생하는 문제점에 대해 설명해주세요.
* 단편화(Fragmentation) 문제
  * 프로세스들이 메모리에 적재되고 제거되는 일이 반복되다보면 메모리 사이에 사용 하지 못할 만큼의 작은 자유 공간들이 늘어나게 되는데 이를 단편화라고 합니다.
* 외부 단편화
  * 메모리에서 프로세스 사이 사이 남는 공간들을 의미합니다.
* 내부 단편화
  * 프로세스가 사용하는 메모리 공간에서 남는 부분을 의미합니다.

## ❓ 외부 단편화를 해소하기 위한 방법은 무엇이 있을까요?
* 압축
  * 외부 단편화를 해소하기 위해 프로세스가 사용하는 메모리 공간들을 한쪽으로 몰아, 자유 공간을 확보하는 방법을 의미합니다.
  * 작업효율이 좋지 않아 잘 사용하지 않습니다.
* 페이징 기법
  * 메모리 공간이 연속적이어야 한다는 제약을 없앱니다.
  * 물리 메모리를 Frame 이라는 고정 크기로 분리하고, 논리 메모리는 페이지라 불리는 고정 크기의 블록으로 분리하는 기법입니다.
  * 이러한 페이징 기법을 통해 논리 메모리는 물리 메모리에 저장될 때, 연속되어 저장될 필요가 없고 물리 메모리의 남는 프레임에 적절히 배치됨으로 외부 단편화를 해결할 수 있습니다.
  * 하나의 프로세스가 사용하는 공간을 여러 개의 페이지로 나뉘어서 논리 메모리에서 관리하고, 개별 페이지는 순서에 상관없이 물리 메모리에 있는 프레임에 mapping되어 저장하는 방법입니다.
  * 하지만 페이지의 크기는 정해져 있기 때문에 내부 단편화는 발생할 수 있습니다.

## ❓ Segmentation 세그멘테이션이란 무엇입니까?
* 프로세스를 물리적 크기의 단위가 아닌 논리적 내용의 단위인 세그먼트로 분할하고 메모리를 할당하며 주소를 변환하는 기법을 의미합니다.
* 세그먼트들의 크기가 서로 다르기 때문에 메모리를 페이징 기법에서처럼 미리 분할해 둘 수 없고, 메모리에 적재될 때 빈 공간을 찾아 할당하는 사용자 관점의 가상 메모리 관리 기법입니다.
* 세그먼트의 단위가 다르기 때문에 메모리에 서로 다른 크기를 가진 여러 세그먼트를 저장할 시 외부 단편화가 생기는 문제점이 존재해 잘 사용하지는 않습니다.

<br>

---

<br>

# 📌 Virtual Memory 가상 메모리
## ❓ 가상메모리에 대해 설명해주세요.
* 가상 메모리는 프로세스가 실제 메모리의 크기와 상관없이 메모리를 이용할 수 있도록 지원하는 기술입니다.
* 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법이며, 프로그램이 물리 메모리보다 커도 된다는 주요 장점이 있습니다.
* 실제 메모리(RAM, main memory, first storage)와 보조 기억 장치(auxiliary storage, secondary storage)의 Swap 영역으로 구성되어 있습니다.
* OS는 메모리 관리자(Memory Management Unit)를 통해 메모리를 관리합니다.
* 프로세스는 사용하는 메모리가 실제 메모리인지, Swap 영역인지 모릅니다.
* Java 에서는 Swap 영역을 잡아주지 않은 경우 OOM(Out Of Memory)이 발생할 수 있습니다.
* Swap 영역은 실제 메모리가 아니기 때문에 지연시간이 많이 발생하며, 가급적이면 Swap 메모리를 사용하지 않도록 설계하는 것이 좋고, 만약 계속해서 사용하는 양이 증가한다면 메모리 누수를 의심해 볼 수 있습니다.

## ❓ 가상 메모리가 탄생하게 된 배경에 대해 설명해주세요.
* 실행되는 코드의 전부를 물리 메모리에 존재시켜야 했고, 메모리 용량보다 큰 프로그램은 실행시킬 수 없었습니다.
* 또한 멀티 프로세스상에서 여러 프로그램을 동시에 메모리에 올리기에는 용량의 한계와, 페이지 교체등의 성능 이슈가 발생했기 때문입니다.

## ❓ 요구 페이징 (Demand Paging)이란 무엇인가요?
* 프로그램 실행 시작 시에 프로그램 전체를 디스크에서 물리 메모리에 적재하는 대신, 초기에 필요한 것들만 적재하는 전략을 의미합니다.
* 가상 메모리 시스템에서 많이 사용합니다.
* 요구 페이징을 사용하는 가상 메모리에서는 실행과정에서 필요해질 때 페이지들이 적재됩니다.

## ❓ 페이지 교체 알고리즘이란 무엇인가요?
* 요구 페이징에서 언급된대로 프로그램 실행시에 모든 항목이 물리 메모리에 올라오지 않기 때문에, 프로세스의 동작에 필요한 페이지를 요청하는 과정에서 page fault가 발생하게 되면, 원하는 페이지를 보조저장장치에서 가져오게 되는 것을 의미합니다.

## ❓ 페이지 교체 알고리즘의 순서에 대해 설명해주세요.
* 디스크에서 필요한 페이지의 위치를 찾습니다.
* 빈 페이지 프레임을 찾습니다.
* 페이지 교체 알고리즘을 통해 희생될(victim) 페이지를 고릅니다.
* 희생될 페이지를 디스크에 기록하고, 관련 페이지 테이블을 수정합니다.
* 새롭게 비워진 페이지 테이블 내 프레임에 새 페이지를 읽어오고, 프레임 테이블을 수정합니다.
* 사용자 프로세스를 재시작합니다.

## ❓ 페이지 교체 알고리즘 종류에 대해 설명해주세요.
* FIFO 페이지 교체 : 먼저 물리 메모리에 들어온 페이지 순서대로 페이지 교체 시점에 먼저 나가게 된다.
* 최적 페이지 교체 : 앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체하는 알고리즘이다.
* LRU (Least Recently Used) 페이지 교체 : 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체한다. (최적 알고리즘 근사 알고리즘)
* LFU (Least Frequently Used) 페이지 교체 : 참조 횟수가 가장 적은 페이지를 교체하는 방법이다.
* MFU (Most Frequently Used) 페이지 교체 : 참조 횟수가 가장 많은 페이지를 교체하는 방법이다.

<br>

---

<br>

# 📌 Caching(Cache) 캐시
## ❓ 캐시 메모리란 무엇인가요?
* 캐시 메모리란 속도가 빠른 장치와 느린 장치간의 속도차에 따른 병목 현상을 줄이기 위한 범용 메모리입니다.

## ❓ 캐시 메모리에서 가장 신경써야 하는 문제는 무엇인가요?
* 캐시 메모리의 역할을 수행하기 위해서는 CPU가 어떤 데이터를 원할 것인가를 예측할 수 있어야 합니다.
* => **적중률(hit rate)**을 극대화 시켜야 합니다.

## ❓ 적중률(hit rate)을 극대화 시키기 위한 방법은 무엇인가요?
* 적중률을 극대화 시키기 위해 **데이터 지역성(Locality)**의 원리를 사용합니다.
* => Locality란 기억 장치 내의 정보를 균일하게 Access 하는 것이 아닌 어느 한 순간에 특정 부분을 집중적으로 참조하는 특성을 의미합니다.

## ❓ 캐시의 지역성에 대해 설명해주세요.
* 시간 지역성 : 최근에 참조된 주소의 내용은 곧 다음에 다시 참조되는 특성을 의미합니다.
* 공간 지역성 : 대부분의 실제 프로그램이 참조된 주소와 인접한 주소의 내용이 다시 참조되는 특성을 의미합니다.
