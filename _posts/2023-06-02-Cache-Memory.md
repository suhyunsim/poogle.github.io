---
layout: post
title: "메모리와 캐시"
author: "Poogle"
categories: [BackEnd]
sitemap:
  changefreq: daily
  priority: 1.0
comments: true
tag: [RAM, ROM, 물리 주소와 논리 주소, 캐시 메모리]

---


> _참고 링크_
>
> **Books**
>
> [강민철(2022). 혼자 공부하는 컴퓨터 구조 + 운영체제. 한빛미디어](http://www.yes24.com/Product/Goods/111378840)
>
> [책 - 실습과 그림으로 배우는 리눅스 구조](http://www.yes24.com/Product/Goods/69660412)
>
> **Youtube Videos**
>
> [[10분 테코톡] 🐻큰곰의 Cache](https://www.youtube.com/watch?v=c33ojJ7kE7M&t=176s)
>

<br>

<br>

이번 글에서는 아래 정리한 순서에 따라 RAM과 캐시 메모리에 관련된 여러 가지 주제들을 다뤄보려고 합니다.

```text
- 컴퓨터의 4가지 핵심
  - 중앙처리장치(CPU) / 주기억장치(메모리) / 보조기억장치 / 입출력장치
- 주기억장치
  - ROM / RAM
- RAM
  - 특징, 용량, 성능, 종류
- 물리 주소와 논리 주소
  - 주소 변환 예제
- 캐시 메모리
  - 저장 장치 계층 구조
  - 캐시 읽기, 쓰기, 더티 플래그
  - 참조 지역성 원리
```

<br>

<br>
# 컴퓨터를 구성하는 핵심 부품

<img width="954" alt="image" src="https://github.com/suhyunsim/Algorithm_Practice/assets/58318786/678a2588-a571-495d-9f14-5398a2080518">
* 우선 메인보드 안에 CPU와 시스템버스, 메모리가 있습니다.
  * CPU 내부에는 ALU (산술논리연산장치), 제어장치와 여러 레지스터가 있습니다.
* 메인보드 외부에는 보조기억장치, 입출력장치 등이 있고 이러한 부품들은 내부의 CPU, 메모리는 메인보드 내 시스템 버스와 연결되어 있습니다.
  * 이 중 오늘 살펴 볼 **메모리**는 현재 실행되는 프로그램의 명령어와 데이터를 저장하는 부품으로 컴퓨터가 빠르게 작동하기 위해서는 저장된 메모리 속 명령어와 데이터 값에 빠르고 효율적으로 접근해야 합니다.
  * 이 때 주소의 개념을 사용합니다.

<br>
 
---

<br>

# 주기억장치
이어서 메모리, 즉 주기억장치에 대해 자세히 알아보겠습니다.

<img width="1036" alt="image" src="https://github.com/suhyunsim/Algorithm_Practice/assets/58318786/6ee113b9-e396-49a7-89eb-ea7d0ad92256">

* 컴퓨터 내부에서 현재 CPU가 처리하고 있는 내용을 저장하고 있는 기억장치는 주기억장치라고 하고 주기억장치에는 크게 RAM과 ROM이 있는데 메모리라는 용어는 보통 RAM을 지칭하곤 합니다.
* 먼저 **ROM**은 Read Only Memory로 전원이 끊어져도 기록된 데이터가 소실되지 않습니다. 
  * 즉 비휘발성 메모리(Non-Volatile Memory)라고 합니다. 
  * 따라서 데이터를 저장한 후 반영구적으로 사용하곤 합니다. 
  * 보통 시스템에 기억시키고 변화시키면 안되는 BIOS 같은 주요 데이터들을 저장합니다. 
  * 이런 ROM의 종류로는 Mask ROM, OTP(One Time PROM), EPROM(Erasable PROM), EEPROM(Electrically Erasable PROM), UVEPROM… 등이 있습니다.
* 다음으로 **RAM**은 Random Access Memory로 읽고 쓰기가 가능하고, 응용 프로그램아너 운영체제 등을 불러와 CPU가 작업할 수 있게 하는 기억장치입니다.
  * 전원이 끊어지면 데이터가 전부 지워지기 때문에 휘발성 메모리(Volatile Memory)라고 하고, 
  * 보통 데이터를 읽는 속도와 기록하는 속도가 같고 프로그램을 로딩하거나 데이터를 임시 저장하는 곳에 사용합니다. 
  * RAM의 종류로는 SRAM, DRAM, SDRAM, DDR SDRAM 등이 있는데 하나씩 살펴보도록 하겠습니다.


<br>
 
---

<br>

# RAM

<img width="1097" alt="image" src="https://github.com/suhyunsim/Algorithm_Practice/assets/58318786/1906544d-434b-41d0-b5a4-fec8670748a9">

* 보조기억장치는 전원을 꺼도 내용을 유지하지만 CPU는 보조기억장치에 직접 접근하지 못합니다. 
* 따라서 보조기억장치(비휘발성 저장장치)에는 보관할 대상을 저장하고 RAM(휘발성 저장장치)에는 실행할 대상을 저장합니다. 
* 다시 말해서 CPU가 실행하고 싶은 프로그램이 보조기억장치에 있으면 RAM에 복사해서 저장 후 실행하게 되는데요.

<img width="606" alt="image" src="https://github.com/suhyunsim/Algorithm_Practice/assets/58318786/09c720e5-5da9-4770-8562-e0883d3c2820">

* 이를 쉽게 생각하면 CPU가 실행할 프로그램은 책으로 생각하고, 보조기억장치는 책이 꽂혀 있는 책장으로 생각하면 됩니다.
* 그리고 RAM은 책을 읽을 수 있는 책상과 같습니다. 
* 책을 읽을 수 있는 책상이 크다면 책장으로부터 많은 책을 미리 책상으로 가져와서 여러 권을 동시에 읽을 수 있기 때문에 책을 가지러 왔다 갔다 하는 시간을 절약할 수 있습니다. 
* 이처럼 RAM 용량이 크면 많은 프로그램들을 동시에 빠르게 실행하는 데 유리합니다.
* 그럼 RAM 용량이 크면 클수록 프로그램 실행 속도는 그에 비례하여 항상 점점 더 빨라질까요? 또 그렇지는 않습니다. 
* RAM 용량이 커지면 프로그램 실행 속도가 어느 정도 증가하는 것은 맞지만, 용량이 필요 이상으로 커졌을 때 속도가 그에 비례하여 증가하지는 않습니다. 
* 책을 100권 이상 올려놓을 수 있는 책상에서 책을 읽든, 1,000권 이상 올려놓을 수 있는 책상에서 책을 읽든 간에 책장을 오가는 시간에는 별 차이가 없기 때문입니다.


<br> 

## RAM의 종류

<img width="593" alt="image" src="https://github.com/suhyunsim/Algorithm_Practice/assets/58318786/2a93f7d6-3d49-4424-b821-fc3acf8731e5">

* RAM에는 우선 크게 Dynamic RAM인 DRAM과 Static RAM인 SRAM이 있습니다.
* DRAM은 Dynamic이라는 말에서 보시다시피 저장된 데이터가 동적으로 변하는 램입니다. 
  * 즉 시간이 지나면 데이터가 소멸되기 때문에 일정 주기마다 재충전을 해줘야 합니다. 
  * 이런 불편함이 있지만 주로 메모리로는 DRAM을 쓰는데 가격이 저렴하고 집적도가 높아서 대용량으로 설계하기 쉽기 때문입니다.
* Static RAM인 SRAM은 전원이 공급된다는 전제 하에 시간이 지나도 저장된 내용이 사라지지 않는데 그렇기 때문에 재활성할 필요는 없습니다. 
  * 속도도 DRAM보다 빠르지만 집적도가 낮고 소비 전력이 크며 더 비싸기 때문에 대용량으로 만들어질 필요는 없지만 속도가 빨라야 하는 캐시에서 보통 사용합니다.

<img width="333" alt="image" src="https://github.com/suhyunsim/Algorithm_Practice/assets/58318786/9a7f9d4d-ee5f-4a10-87a9-6522a9196d9c">

* 추가로 SDRAM과 DDR SDRAM이 있는데 SDRAM은 클럭신호와 동기화된 발전된 형태의 DRAM입니다. 
* 그리고 가장 흔히 쓰는 DDR SDRAM은 대역폭(데이터 주고받는 길 너비)을 넓혀 속도를 빠르게 만든 SDRAM입니다. 
* 그래서 SDRAM 보다 2배 대역폭이 넓고 DDR에 붙는 숫자만큼 2배씩 넓은 SDRAM이라고 보시면 될 것 같습니다.

<br>

---

<br>

# 물리 주소와 논리 주소

* CPU와 실행 중인 프로그램은 메모리에 저장된 정보가 예를들어 새로 실행되는 프로그램이 실시간으로 적재되고 실행 끝난 프로그램이 삭제되는 등 계속해서 변하기 때문에 현재 매모리 몇 번지에 무엇이 저장되어 있는지 다 알고 있진 않습니다. 
* 또 같은 프로그램이더라도 실행될 때마다 다른 주소에 적재될 수 있기 때문에 CPU와 실행중이 프로그램이 이해하는 주소와 메모리가 사용하는 주소는 다릅니다. 
* 여기서 메모리가 사용하는 물리 주소가 있고, CPU와 실행 중인 프로그램이 사용하는 논리 주소가 있습니다.

* 메모리가 사용하는 **물리 주소**는 말 그대로 정보가 실제로 저장된 하드웨어상의 주소를 의미합니다. 
* 반면 CPU와 실행 중인 프로그램이 사용하는 **논리 주소**는 실행 중인 프로그램 각각에게 부여된 0번지부터 시작되는 주소를 의미합니다.
* 그런데 이제 CPU가 메모리랑 상호작용을 하려면 논리 주소와 물리 주소 간 변환이 이루어져야 하는데 이런 변환은 메모리 관련 장치인 MMU라는 하드웨어에 의해 수행이 됩니다. 
  * MMU는 CPU의 논리주소에 프로그램의 가장 작은 물리 주소인 베이스 레지스터 값을 더해서 물리주소를 계산합니다.

<img width="1065" alt="image" src="https://github.com/suhyunsim/Algorithm_Practice/assets/58318786/fcda200d-60be-4c6c-882a-8d01c3a56898">

* 🤔 예를 들어 CPU가 발생시킨 논리 주소가 프로그램 A의 100번지 데이터를 조회하는 것이라면?
* MMU는 베이스 레지스터에 저장된 15000을 100에 더해서 물리주소를 15100번지라는 것을 알아냅니다. 
* 즉, 물리주소 15000번지부터 적재된 프로그램 A의 논리 주소가 15100번지다 이렇게 알고 접근할 수 있는 것입니다. 
* 만약 프로그램 C의 논리주소 100번지를 물리주소로 변환하고 싶다면 프로그램 C의 베이스 레지스터인 45000을 더해서 45100번지로 물리주소를 알 수 있습니다.

<br>

<img width="1102" alt="image" src="https://github.com/suhyunsim/Algorithm_Practice/assets/58318786/a41a68d4-c641-48b5-ada2-317878d3d769">

* 🤔 그런데 만약에 프로그램 A의 1200번지 데이터를 삭제하라는 논리 주소 접근이 일어나면 어떻게 될까요? 
* 프로그램 A의 베이스 레지스터가 1500일 때 2700번지는 프로그램 A이 아닌 프로그램 B의 논리주소이기 때문에 엉뚱한 데이터가 삭제될 수 있습니다. 
* 이렇게 다른 프로그램의 영역을 침범할 수 있는 명령어는 위험하기 때문에 메모리 보호 기법으로 **한계 레지스터**를 사용합니다. 
  * _논리 주소 범위를 벗어나는 명령어가 실행되는 것을 방지하기 위해_ 한계 레지스터는 논리 주소의 최대 크기를 저장해 실행 중인 프로그램이 다른 프로그램에 영향을 받지 않도록 보호합니다. 
  * 다시 말해 접근하려고 하는 논리주소가 한계 레지스터보다 작은지를 검사해서 프로그램을 검사하는 방법입니다.

<br>

---

<br>

# 캐시 메모리

## 저장 장치 계층 구조

<img width="1034" alt="image" src="https://github.com/suhyunsim/Algorithm_Practice/assets/58318786/7512b468-09c5-4b4c-b5cb-33c38a88eadf">

* 저장 장치 계층 구조는 CPU에 얼마나 가까운지를 계층적으로 나타낸 것으로 보통 레지스터 -> 캐시 -> 메모리 -> 보조기억장치 순으로 정리된 것을 볼 수 있습니다.
해당 순서대로 속도는 빨라지고 용량은 작고 가격은 비싼 형태를 보이는데요.

<br>

## 캐시 메모리가 등장하게 된 배경

<img width="483" alt="image" src="https://github.com/suhyunsim/Algorithm_Practice/assets/58318786/c63cf5c7-74e9-49be-9ee7-2cae72d1fe83">

* 캐시 메모리가 등장하게 된 배경은 CPU가 메모리에 접근하는 시간이 CPU의 연산 속도보다 느리기 때문인 것을 알 수 있습니다. 
* 예를 들어 명령어를 바탕으로 메모리에서 레지스터로 데이터를 읽고, 레지스터에 있는 데이터를 바탕으로 계산하는 연산이 이루어지고 그 계산 결과를 메모리에 다시 쓰는 처리들이 있을 때, 요즘 하드웨어는 레지스터에서 계산하는 평균 시간보다 메모리에 접근하는데 걸리는 시간, 즉 레이턴시가 극도로 느리기 때문에 아무리 빠르게 계산 처리가 이뤄져도 CPU가 레지스터에 접근하는 시간이 병목이 되어 전체 속도가 느려집니다. 
  * ✅ 이런 문제점을 해결하기 위해 캐시가 등장합니다. 
  * CPU와 메모리 사이에 위치해서 CPU의 연산 속도와 메모리 접근 속도의 차이를 조금이나마 줄이는 것입니다.
  * 메모리에서 CPU가 사용할 일부를 미리 캐시 메모리에 옮겨와서 활용하는 것입니다.

<br>

## 캐시 메모리 읽기, 쓰기, 더티

<img width="975" alt="image" src="https://github.com/suhyunsim/Algorithm_Practice/assets/58318786/3d334894-326a-43c4-ae7c-795c02c02eff">

* 캐시 메모리에 읽고 쓰는 과정을 한 번 간단히 보면,
  * 예를 들어 레지스터 R0에 메모리 주소 300번지 데이터를 읽는다고 할 때, 한 번 읽고 나서 이후에 CPU가 주소 300번지의 데이터를 다시 R1에 읽어들일 경우, 메모리에 접근하지않고 캐시 메모리에만 접근하면 됩니다. 
  * 여기서 CPU가 캐시 메모리에 있는 데이터에만 접근할 때는 모든 접근이 캐시 메모리의 속도로 처리되므로 캐시 메모리가 없는 경우보다 훨씬 빠르게 처리됩니다.

<br>

<img width="728" alt="image" src="https://github.com/suhyunsim/Algorithm_Practice/assets/58318786/5b6b48da-7675-4487-b69a-fb3f749302a3">

* 만약에 R0의 값이 새로 덮어 씌어진 경우에는 다음에 레지스터로부터 300번지의 데이터를 써넣는 경우에 변경된 데이터를 캐시 메모리에 적어둡니다. 
* 이 때 캐시 라인에 메모리로부터 읽어들인 데이터가 변경되었다는 것을 의미하는 **더티** 라는 플래그에 표시를 해둡니다.

<br>

<img width="373" alt="image" src="https://github.com/suhyunsim/Algorithm_Practice/assets/58318786/c8a30a5b-9192-492f-93ad-84faf285c251">

* 그리고 더티 플래그가 붙어있는 데이터는 나중에 백그라운드 처리로 메모리에 다시 기록 됩니다. 
* 이걸 write back이라고 하는데요, 이렇게 다시 기록된 후에는 해당 캐시 라인은 더티가 아니게 됩니다.

<br>

## 캐시 히트, 미스, 적중률

* 캐시 히트(Cache Hit)
  * 자주 사용될 것으로 예측한 데이터가 실제로 들어맞아 캐시 메모리 내 데이터가 CPU에서 활용될 경우를 의미합니다.
* 캐시 미스(Cache Miss)
  * 자주 사용될 것으로 예측하여 캐시 메모리에 저장했지만 예측이 틀려 메모리에서 필요한 데이터를 직접 가져와야 하는 경우를 의미합니다.
  * 캐시 미스가 자주 발생하면 성능이 떨어지기에 주의해야 합니다.
* 캐시 적중률(Cache Hit Ratio)
  * 캐시가 히트되는 비율을 의미합니다.
  * 캐시 히트 횟수 / (캐시 히트 횟수 + 캐시 미스 횟수)
  * 캐시 적중률이 높으면 CPU의 메모리 접근 횟수를 줄일 수 있습니다.

<br>

## 참조 지역성 원리

* 🤔 그렇다면 캐시 적중률을 높이기 위해 CPU가 사용할 법한 데이터를 알아내기 위해 사용하는 원리엔 뭐가 있을까요?
  * 바로 참조 지역성 원리입니다. (CPU가 메모리에 접근할 때 주된 경향을 바탕으로 만들어진 원리)

* 시간 국소성(시간 지역성; temporal locality) 
  * 최근에 접근했던 메모리 공간에 다시 접근하려는 경향을 말합니다. 
  * CPU는 변수가 저장된 메모리 공간을 언제든 다시 참조할 수 있기 때문에 CPU는 최근에 접근했던 (변수가 저장된) 메모리 공간을 여러 번 다시 접근할 수 있습니다.
* 공간 국소성(공간 지역성; spatial locality)
  * 접근한 메모리 공간 근처를 접근하려는 경향을 말합니다.
  * CPU가 실행하려는 프로그램은 보통 관련 데이터들끼리 한데 모여있고 하나의 프로그램 내에서도 관련있는 데이터들은 모여서 저장되니까 이렇게 시간 국소성, 공간 국소성을 참고해서 캐시 적중률을 높일 수 있도록 하는 것이 좋습니다.
