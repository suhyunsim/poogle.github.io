---
layout: post
title: "DB 면접 질문 모음"
author: "Poogle"
categories: [BackEnd]
sitemap:
changefreq: daily
priority: 1.0
comments: true
tag: [DB]

---

> 참고 링크
>
> [[실무 면접 준비 - 3] 데이터베이스 & 네트워크 (Database & Network)](https://imbf.github.io/interview/2021/03/01/NAVER-Practical-Interview-Preparation-3.html)
>
> [내가 받은 '백엔드 기술 면접 질문' 모음](https://velog.io/@wijoonwu/%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8)
>
> [[데이터베이스] 무결성 제약조건](https://kosaf04pyh.tistory.com/202)

# DB 기본
## 데이터베이스란?
* 데이터베이스란 여러 사람이 공유하여 사용할 목적으로 통합되어 관리되는 데이터의 집합을 의미
* 데이터베이스를 관리하는 시스템: 데이터베이스 시스템(DBMS)

## 데이터베이스의 특징?
* **독립성(Independence)**
  * 데이터베이스는 데이터를 사용하는 응용 프로그램과 독립적으로 데이터를 저장 및 관리
  * 물리적 독립성: 데이터베이스 사이즈를 늘리거나 성능 향상을 위해 데이터 파일을 새롭게 추가하더라도 관련된 응용 프로그램을 수정할 필요가 없음
  * 논리적 독립성: 데이터베이스는 논리적인 구조로 다양한 응용 프로그램의 논리적 요구를 만족시켜줄 수 있음
* **무결성(Integrity)**
  * 데이터베이스는 다양한 제약조건 및 기능을 통해 데이터의 무결성을 유지
* **보안성(Security)**
  * 데이터베이스는 계정 및 권한 관리(인가된 사용자만 자원에 접근)를 통해 데이터들의 보안을 유지
* **일관성(Consistency)**
  * 데이터베이스는 다양한 제약조건을 통해 데이터를 일관되게 유지함, 어떤 하나의 데이터만 변경했을 경우 발생할 수 있는 데이터의 불일치성을 배제할 수 있음, 작업 중 일부 데이터만 변경되어 나머지 데이터와 일치하지 않는 경우의 수를 배제할 수 있음
* **중복 최소화(Minimum Duplication)**
  * 데이터베이스는 데이터를 통합해서 관리함으로써 데이터의 중복을 최소화

## 데이터 무결성이란?
* 데이터에 결함이 없는 상태, 데이터를 정확하고 유효하게 유지하는 것
* 데이터의 정확성과 일관성을 유지하고 보증하기 위해 데이터베이스에 삽입, 삭제, 수정, 연산이 일어나도 무결성 제약조건은 지켜져야 함

## 무결성 제한의 유형
* **개체 무결성(Entity Integrity)**: 모든 테이블은 기본 키(primary key)를 가져야 하며 기본 키로 선택된 열은 고유하고 빈 값은 허용되지 않음을 규정, 기본키는 null이 될 수 없음
* **참조 무결성(Referential Integrity)**: 모든 외래 키 값은 Null이거나 참조 릴레이션의 기본키 값과 동일해야 한다는 규정. 즉, 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다는 규정
* **범위(도메인) 무결성(Domain Integrity)**: 정의된 범위에서 관계형 데이터베이스의 모든 열이 선언되도록 규정
* 키 무결성(Key Integrity): 릴레이션에는 최소한 하나의 키가 존재해야 함
* null 무결성(Null Integrity): 특정 속성은 null 값을 가질 수 없음
  * null 무결성은 특정 속성값에는 null 값을 가질 수 없다는 규칙
  * ex. 기본적으로 속성값으로 null 값을 가질 수 있는데 만약 "유저 아이디"처럼 중요한 정보에는 스키마를 정의할 때 해당 속성을 null 데이터가 올 수 없음을 미리 정의할 수 있음
* 고유 무결성(Unique Integrity): 특정 속성값은 서로 달라야 함
  * 고유 무결성은 특정 속성에 삽입되는 데이터는 고유한 값을 가져야 한다는 규칙
  * 각 튜플에서 하나의 속성값은 중복된 값이 없는 각각 서로 다른 값을 가져야 한다는 의미
  * ex. 이름, 나이, 사는 곳과 같은 속성은 튜프들이 서로 같은 값을 가질 수 있지만 고객 아이디의 경우 각 튜플을 서로 다른 값을 가져야 함

## 외래키는 NULL이 허용되나요?
1) 외래키 값은 NULL이거나 부모 테이블의 기본키 값과 동일해야한다. (참조 무결성 제약조건)
2) 부모 테이블의 기본키, 고유키를 외래키로 지정할 수 있다.
3) 부모 테이블의 기본키, 고유키가 여러개의 컬럼으로 이루어져 있다면 부모가 가진 기본키, 고유키 컬럼을 원하는 개수만큼 묶어서 외래키로 지정할 수 있다.
4) 외래키로 지정할 두 테이블의 필드는 같은 데이터 타입이어야 한다.

<br>

## RDBMS vs NOSQL에 대해서 설명해주세요.
* 둘은 대체될 수 있는 것이 아니고, 각각 필요한 시점에 적절히 선택해서 사용해야 함, 둘 다 같이쓰는 상호보완적인 존재가 될 수도 있음

### RDBMS
* 데이터베이스를 이루는 객체들의 릴레이션을 통해서 데이터를 저장하는 데이터베이스
* SQL을 사용해 데이터의 저장, 질의, 수정, 삭제를 할 수 있으며 데이터를 효율적으로 보관하는 것을 목적으로 하고 구조화가 굉장히 중요
* 명확한 데이터 구조를 보장하고, 중복을 피할 수 있음

### NoSQL
* 전통적인 관계형 모델에서 벗어나서 다양한 데이터 모델을 사용하여 데이터의 관리와 접근을 지원하는 데이터베이스를 의미
* NoSQL은 데이터의 스펙이 자주 변경되는 경우나, Read 작업이 자주 일어나는 경우, 수 많은 양의 데이터를 다루기 위해 수평 확장이 자주 필요한 경우에 사용
* NoSQL은 RDBMS에 비해 자유로운 형태로 데이터를 저장
* 수평확장을 할 수 있고 분산처리를 지원
* NoSQL DB ex. key-value store, bigtable, dynamo, document db, graph db 등
* 장점
  * 스키마가 없거나 느슨하게 제공되기 때문에 요구사항 변경에 유연하게 대처
  * 관계형 데이터베이스에 비해 수평 확장이 쉽기 때문에 대용량 데이터 처리시 성능상의 이점
* 단점
  * 데이터베이스마다 사용하는 데이터의 모델이 다르기 때문에 이를 도입하기 위해서는 해당 데이터베이스를 잘 알아야 함
  * SQL처럼 엄격한 제약조건이 존재하지 않기 때문에 데이터를 수정하거나 삭제하는 경우 모든 컬렉션에 걸쳐서 이를 반영해야 하는 단점이 존재
* 데이터 모델에 따라 분류 
  * Key-Value Data Model: 하나의 키에 하나의 데이터가 저장 -> ex. Redis
  * Document Data Model: Key-Value 모델을 개념적으로 확장해서 하나의 키에 하나의 구조화된 문서를 저장 -> ex. MongoDB

### RDBMS의 한계와 NoSQL을 사용하는 이유 - CAP, PACELC 이론
https://sujl95.tistory.com/81

![cap](https://user-images.githubusercontent.com/58318786/209629669-ff673105-f4e5-4203-96fa-74112f9f84a5.png)



<br>

## MySQL
### MySQL 버젼 5.7 vs 8.0 차이점
* 사용자 인증방식 변경
* 외래키 이름의 길이(64bit)
* InnoDB
  1. Auto_Increment의 초기화 방식 변화
  2. NOWAIT and SKIP LOCKED (MySQL 8.0이 Hot rows를 처리하는 방법)
* 데이터 딕셔너리 업그레이드
  * MySQL 5.7 버전까지는 데이터 딕셔너리 정보가 FRM 확장자를 가진 파일로 별도로 보관
  * MySQL 8.0 버전부터는 데이터 딕셔너리 정보가 트랜잭션이 지원되는 InnoDB 테이블로 저장되도록 개선
  * 데이터 딕셔너리 업그레이드는 기존의 FRM 파일의 내용을 InnoDB 시스템 테이블로 저장
  * MySQL 8.0 버전부터는 딕셔너리 데이터의 버전 간 호환성 관리를 위해 테이블이 생성될 때 사용된 MySQL 서버의 버전 정보도 함께 기록
* SQL DDL
* SQL DML
  1. Windows Functions
  2. CTE (Common Tables Expressions)
* Indexes
  1. Descending Indexes
  2. Invisible Indexes
  3. Functional Indexes
* JSON
* GROUP BY에 사용된 정렬 옵션
* 파티션을 위한 공용 테이블 스페이스
* 서버 업그레이드
  * MySQL 서버의 시스템 데이터베이스(performance_schema, information_schema, mysql 데이터베이스)의 테이블 구조를 MySQL 8.0 버전에 맞게 변경

<br>

## H2

<br>

## Redis
Redis는 key-value store NOSQL DB
* 싱글스레드로 동작하며 자료구조를 지원
* 다양한 용도로 사용될 수 있도록 다양한 기능을 지원
* 데이터의 스냅샷 혹은 AOF 로그를 통해 복구가 가능해서 어느정도 영속성도 보장
* 스프링에서는 세션을 관리하거나, 캐싱을 하는데에 자주 사용

### Redis와 Memcached의 차이에 대해서 설명해주세요.
* Redis는 싱글 스레드 기반으로 동작 / Memcached는 멀티스레드를 지원해서 멀티 프로세싱이 가능
* Redis는 다양한 자료구조를 지원 / Memcached는 문자열 형태로만 저장
* Redis는 여러 용도로 사용할 수 있도록 다양한 기능을 지원
* Redis는 스냅샷, AOF 로그를 통해서 데이터 복구가 가능합니다.

## MongoDB

<br>

## Key
* 기본키(Primary Key)
  * 하나의 테이블에서 특정 ROW를 구별할 수 있는 속성(Attribute)을 의미
  * 개체 무결성에 의해 기본키에는 Null 값과 중복된 값이 저장되어질 수 없음
  * 엔티티를 식별하는 대표 Key
  * table 당 1개만 지정
* 외래키(Foreign Key)
  * 참조되는 테이블의 기본키와 대응되어 테이블 간에 참조 관계를 표시하는 키
  * 외래키로 지정되면 참조 무결성에 의해 참조 테이블의 기본키에 없는 값은 입력할 수 없음
  * 두 테이블 간의 종속이 필요한 관계이면 그 접점이 되는 칼럼을 FK로 지정하여 서로 참조할 수 있도록 관계를 맺어줌
  * 테이블 간의 잘못된 매핑을 방지하는 역할도 한다.

<br>

## Join
조인이란 2개 이상의 테이블에서 조건에 맞는 데이터를 추출하기 위하여 사용하는 쿼리문을 의미
* Inner Join: 2개 이상의 테이블에서 교집합만을 추출
* Left Join: 2개 이상의 테이블에서 FROM문에 해당하는 부분을 추출
* Right Join: 2개 이상의 테이블에서 FROM 문의 테이블과 JOIN하는 테이블에 해당하는 부분을 추출
* Outer Join: 2개 이상의 테이블에서 모든 테이블에 해당하는 부분을 추출

![image](https://user-images.githubusercontent.com/58318786/204744082-1f357b0b-fb8a-4b5a-9ffe-d8f417aea1b4.png)

<br>

## UNION vs UNION ALL
* UNION과 UNION ALL 모두 여러개의 SQL문을 합쳐 하나의 SQL문을 만들어 줌
  * UNION
    * 두 쿼리의 결과 중에서 중복되는 값을 삭제하여 나타냄
  * UNION ALL
    * 두 쿼리의 결과 중에서 중복되는 값을 모두 보여줌
    * 중복체크를 하지 않기 때문에 속도가 더 빠름

---

<br>

# Index
## 데이터베이스에서 인덱스를 사용하는 이유 및 장단점에 대해 설명해주세요.
* 데이터베이스에서 인덱스를 사용하는 이유는 **검색성능**을 향상시키기 위함
* 데이터베이스 인덱스란 테이블의 동작 속도(Row 검색 속도)를 높여주는 자료구조를 의미 (ex. 책의 앞 부분에 존재하는 목차)
* 데이터베이스는 인덱스를 따로 저장하며 관계형 DB의 경우에는 테이블로 인덱스를 관리
* 장점
  * 빠른 검색 성능
* 단점
  * 인덱스를 구성하는 비용 즉, 추가, 수정, 삭제 연산시에 인덱스를 형성하기 위한 추가적인 연산이 수행

## 인덱스를 구현하기 위한 자료구조는 어떤게 존재하나요?
### Hash Table
* Key와 Value로 데이터를 저장하는 자료구조
* 빠른 데이터 검색이 필요할 때 유용
* 시간복잡도: O(1)
* Key값을 이용해 고유한 Index를 생성하여 그 Index에 저장된 값을 꺼내오는 구조
* 등호(=) 연산에만 특화되어 있기 때문에 부등호 연산(>, <)이 자주 사용되는 데이터베이스 검색을 위해서는 적절하지 않음
* key-value 기반의 DB인 Redis에는 적절

### B+ Tree
* DB의 인덱스를 위해 자식 노드가 2개 이상인 Binary Tree를 개선시킨 자료구조
* Leaf 노드(데이터 노드)만 인덱스와 함께 데이터(Value)를 가지고 있고, 나머지 노드(인덱스 노드)들은 데이터를 위한 인덱스(key)만을 가짐, Leaf 노드들은 LinkedList로 연결
* B+Tree의 리프노드들은 LinkedList로 연결하여 순차검색을 용이하게 하는 등 인덱스에 맞게 최적화

### [PostgreSQL] GIN(Generalized Inverted Index)
* GIN 자료구조는 인덱스를 적용하는 컬럼의 값을 일정한 규칙에 따라 쪼개고 이를 사용하는 자료구조
* 즉, **LIKE와 같은 연산**이 많을 경우 B+ Tree나 Hash Table 인덱스보다 훨씬 빠르게 동작

## 인덱스를 고려할 때 어떠한 점에 주의해야 하나요?
* 인덱스를 설정할 때 해당 테이블에서 어떠한 쿼리가 자주 사용되는지 분석
  * ex. SELECT가 자주 사용되는 테이블 -> 인덱스 설정시 성능 향상의 효과를 기대할 수 있음 / ⚠️ UPDATE, DELETE, INSERT 쿼리가 자주 사용되는 테이블 -> 오히려 인덱스 설정시 성능이 감소될 수 있음
* 인덱스 설정시 카디널리티(Cardinaity; 전체 행에 대한 특정 컬럼의 중복 수치)가 많이 없는 컬럼을 인덱스로 걸어야 함
* 카디널리티가 낮은 컬럼을 인덱스로 사용 => 인덱스를 통해서 수 많은 row가 검색 -> 다시 Full Search로써 결과값을 검색해야 함
* 카디널리티가 높은 컬럼을 인덱스로 사용 => 인덱스를 통해서 소수의 row만 검색 -> 이들 중 조건에 맞는 row만 반환하면 되기 때문에 성능이 훨씬 좋음

---

<br>

# Transaction
## 트랜잭션에 대해서 설명해주세요.
* 트랜잭션이란 데이터베이스의 상태를 변화시키는 하나의 논리적인 작업 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미
* 트랜잭션은 수행중에 한 작업이라도 실패하면 전부 실패하고, 모두 성공해야 성공이라고 할 수 있음

## 트랜잭션의 특징은 무엇인가요? - ACID
* ACID: 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질
* **Atomicity(원자성)**: 트랜잭션의 연산은 모든 연산이 완벽히 수행되어야 하며, 한 연산이라도 실패하면 트랜잭션은 실패함, 트랜잭션의 연산이 데이터베이스에 모두 반영되든지 아니면 전혀 반영되지 않아야 한다는 것을 의미
* **Consistency(일관성)**: 트랜잭션은 유효한 상태로만 변경, 트랜잭션이 수행된 이후에도 데이터베이스는 언제나 일관성 있는 데이터를 보장해야 한다는 것을 의미
* **Isolation(고립성)**: 트랜잭션은 동시에 실행될 경우 다른 트랜잭션에 의해 영향을 받지 않고 독립적으로 실행
* **Durability(내구성)**: 트랜잭션이 커밋된 이후에는 시스템 오류가 발생하더라도 커밋된 상태로 유지되는 것을 보장 (일반적으로 비휘발성 메모리에 데이터가 저장되는 것을 의미)

## 트랜잭션은 어떻게 동작하나요?
![image](https://user-images.githubusercontent.com/58318786/204743076-59b223e7-d1de-4c09-8c23-a6b767b05146.png)
(1) 트랜잭션 시작

(2) 작업 수행

(3-1) 모든 작업을 이상 없이 완료 -> 해당 트랜잭션을 Commit

(3-2). 작업 진행 중 실패 시 -> 해당 트랜잭션을 Rollback or Abort

## 트랜잭션 격리 수준(Transaction Isolation Levels)에 대해서 설명해주세요.
![output](https://user-images.githubusercontent.com/58318786/204745737-019c1399-fb2c-4f72-ba44-b4deac3c7cb2.gif)

트랜잭션 격리수준은 고립도와 성능의 트레이드 오프를 조절합니다.
* `READ UNCOMMITTED`: 다른 트랜잭션에서 커밋되지 않은 내용도 참조할 수 있음
* `READ COMMITTED`: 다른 트랜잭션에서 커밋된 내용만 참조할 수 있음
* `REPEATABLE READ`: 트랜잭션에 진입하기 이전에 커밋된 내용만 참조할 수 있음
* `SERIALIZABLE`: 트랜잭션에 진입하면 락을 걸어 다른 트랜잭션이 접근하지 못하게 함(성능 매우 떨어짐)

---

<br>

# 정규화(Normalization)
## 정규화는 무엇이며 왜 필요한가요?
* 정규화는 데이터의 중복방지, 무결성을 충족시키기 위해 데이터베이스를 설계하는 것을 의미
* 정규화란 데이터베이스에서 갱신 이상을 없애고 데이터의 중복을 최소화하기 위해 하나의 테이블을 둘 이상의 테이블로 분리하는 작업을 의미
* 갱신 이상에는 삽입 이상, 삭제 이상, 수정 이상 등이 포함

## 갱신 이상
* 삽입 이상(Insertion Anomalies): 원하지 않는 자료가 삽입된다든지, 삽입하는데 자료가 부족해 삽입이 되지 않아 발생하는 이상을 의미
* 삭제 이상(Deletion Anomalies): 하나의 자료만 삭제하고 싶지만, 그 자료가 포함된 튜플 전체가 삭제됨으로써 원하지 않는 정보의 손실이 발생하는 이상을 의미
* 수정 이상(Modification Anomalies): 데이터 수정시 일부의 튜플만 갱신되어 데이터의 일관성에 이상이 생기는 현상을 의미

## 정규형이란 무엇이고 이들의 종류에 대해서 설명해주실 수 있나요?
정규형이란 특정 조건을 만족하는 테이블의 스키마 형태를 말하며 제 1 정규형, 제 2 정규형, 제 3 정규형, BCNF 정규형 등이 존재
* 제 1 정규형: 테이블의 *각 로우에 컬럼의 값이 1개만 있어야 하는 형태*의 테이블 스키마를 의미합니다.
* 제 2 정규형: 제 1 정규형을 만족하면서 *Primary Key가 합성키이며, 부분 종속(Primary Key 중에 특정 컬럼에만 종속된 컬럼)이 없어야 하는 형태*의 테이블 스키마를 의미합니다.
* 제 3 정규형: 제 2 정규형을 만족하면서 *테이블 내의 비주요 속성이 기본 키에만 의존*하는 테이블 스키마를 의미합니다.
* BCNF 정규형: 제 3 정규형을 만족하면서 *모든 결정자가 후보키 집합에 속한 테이블 스키마를 의미*합니다.

## 함수적 종속성(Functional Dependency)
* 속성 값의 의미와 속성 간의 상호 관계로부터 유도되는 제약조건의 일종을 의미
* X와 Y를 임의의 속성 집합이라고 할 때, X의 값이 Y의 값을 유일하게(unique) 결정한다면 “X는 Y를 함수적으로 결정한다”라고 함


Elastic Search에 대해서 간단히 설명해주세요.
Elastic Search의 인덱스구조와 RDBMS의 인덱스 구조의 차이에 대해 설명해주세요.
Elastic Search의 키워드 검색과 RDBMS의 LIKE 검색의 차이에 대해 설명해주세요.

CAP 이론과, Eventual Consistency에 대해서 설명해주세요.

