---
layout: post
title: "INDEX 톺아보기"
author: "Poogle"
categories: [BackEnd]
sitemap:
changefreq: daily
priority: 1.0
comments: true
tag: [index]

---

> _참고 링크_
> 
> **Books** 
> 
> [Real MySQL 8.0 (1권)](http://www.yes24.com/Product/Goods/103415627)
> 
> **Youtube Videos** 
> 
> [index가 뭔지 설명해보세요 (개발면접시간)](https://youtu.be/iNvYsGKelYs)
> 
> [(1부) B tree의 개념과 특징, 데이터 삽입이 어떻게 동작하는지를 설명합니다! (DB 인덱스과 관련있는 자료 구조)](https://youtu.be/bqkcoSm_rCs)
> 
> **Articles**
> 
> []()

<br>

백엔드 개발자 면접을 준비하면서 자주 접하게 된 키워드 **`index`** 에 관련된 여러 가지 주제들을 다뤄보려고 합니다.

<br>

```text

```

<br>

# 🏷️ INDEX란?
* 보통 책의 맨 끝에 있는 찾아보기(또는 '색인')를 인덱스로 비유하곤 합니다.
  * 찾아보기 -> 인덱스
  * 책의 내용 -> 데이터 파일
  * 찾아보기를 통해 알아낼 수 있는 페이지 번호 -> 레코드의 주소
* 인덱스와 찾아보기는 최대한 빠르게 찾아갈 수 있게 주어진 순서로 미리 정렬해서 보관한다는 공통점이 있습니다.
* DB 안의 레코드를 처음부터 full-scan 하지 않고 여러 자료 구조를 사용해서 파일 검색 속도를 향상시킵니다.
  * 데이터 조회 성능 향상

# 인덱스 사용의 장/단점
## 👍 장점
* Key 값을 기초로 테이블에서 검색과 정렬 속도를 향상시킵니다.
* 그룹화 작업의 속도를 향상시킵니다.
* 테이블 행의 고유성을 강화시킵니다.
* 다중 필드 인덱스를 사용해 레코드를 구분할 수 있습니다.

## 👎 단점
* 정렬된 상태를 계속 유지시켜줘야 합니다.
* 여러 사용자가 한 페이지를 동시에 수정할 수 있는 병행성이 줄어듭니다.
* 인덱스로 사용하는 필드에서 데이터를 업데이트하거나 레코드를 추가 삭제할 때 성능이 떨어집니다.
* 인덱스가 데이터베이스 내 공간을 차지해 추가적인 공간이 필요합니다.
* 인덱스를 생성하는데 시간이 소요될 수 있습니다.

<br>

# 🤔 상황 별 접근 - 언제 인덱스를 만들면 좋을까요?
## 사용하면 좋은 경우
* Where절에서 자주 사용되는 칼럼
* 외래키가 사용되는 칼럼
* Join에서 자주 사용되는 칼럼

### Cardinality 카디널리티
* 데이터베이스 테이블의 특정 열에 포함된 데이터 값의 고유성을 나타냅니다.
* 카디널리티가 낮을수록 열에 더 많은 중복 요소가 있습니다. (카: 낮 -> 중: 높 / 카: 높 -> 중: 낮)
* => 즉, 카디널리티가 높을수록(ex. 성별 < 학년 < 이름 < 주민등록번호) 인덱스로 선정하기 좋은 칼럼이 됩니다.

## 사용을 피해야 하는 경우
* Data 중복도가 높은 칼럼
* DML이 자주 일어나는 칼럼

### DML과 인덱스
* INSERT
  * index split 현상: 인덱스는 데이터가 순서대로 정렬되어야 하는데 기존 블록에 여유 공간이 없는 상황에서 그 블록에 새로운 데이터가 입력될 경우, 기존 블록의 내용 중 일부를 새 블록에 기록한 후 기존 블록에 빈 공간을 만들어서 새로운 데이터를 추가합니다.
    * 많은 Redo가 유발됩니다.
    * DML 블로킹으로 인해 대기 이벤트가 발생합니다.
* DELETE
  * 테이블에서 데이터가 삭제되어도(삭제 후 공간 비우기) 인덱스에서 데이터가 지워지지 않고 사용하지 않는다는 표시만 해 테이블의 데이터 수와 인덱스의 데이터 수가 다를 수 있습니다.
* UPDATE
  * 인덱스에는 업데이트 개념이 없어서 DELETE -> INSERT 두개의 작업의 연속으로 동작이 일어나 다른 DML보다 더 큰 부하가 생길 수 있습니다.

<br>

---

<br>

# 인덱스의 역할별 분류 - Primary vs. Secondary
## Primary Index
* 그 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스를 의미합니다.
* 이 칼럼(or 칼럼 조합)은 테이블에서 해당 레코드를 식별할 수 있는 기준값이 되기 때문에 식별자라고도 부릅니다.
* NULL, 중복값을 허용하지 않습니다.

## Secondary Index
* 프라이머리 키를 제외한 나머지 모든 인덱스는 Secondary Index가 됩니다.
* Unique Index는 Primary Key와 성격이 비슷하고 대체해서 사용할 수도 있어서 대체 키라고도 하는데 별도로 분류하기도 하고 그냥 Secondary로 분류하기도 합니다.

<br>

# 데이터의 저장 방식(알고리즘)별 분류 - B-Tree vs. Hash
## B-Tree
* 가장 일반적으로 사용되는 인덱스 알고리즘입니다.
* 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘입니다.
* cf.) MySQL의 위치 기반 검색을 위한 R-Tree 인덱스 알고리즘도 B-Tree의 응용 알고리즘입니다.

## Hash
* 칼럼의 값으로 해시값을 계산해서 인덱시하는 알고리즘입니다.
* 매우 빠른 검색을 지원하는 특징이 있습니다.
* 하지만 값을 변형해서 인덱싱하므로 전방(prefix)일치와 같이 값의 일부만 검색하거나 범위를 검색할 때는 해시 인덱스를 사용할 수 없습니다.
* Hash 인덱스는 주로 메모리 기반의 데이터베이스에서 많이 사용합니다.

### Q. 왜 데이터 접근 시간복잡도가 `O(1)`인 Hash 인덱스보다 B-Tree를 많이 사용할까요?
* SELECT 질의의 조건에는 부등호(<>) 연산도 포함이 되기 때문입니다.
* Hash 인덱스를 사용하게 된다면 등호(=) 연산이 아닌 부등호 연산의 경우에 문제가 발생합니다.

<br>

# 데이터 중복 허용 여부별 분류 - Unique vs. Non-Unique
* 인덱스가 유니크한지 아닌지는 단순히 같은 값이 1개만 존재하는지 1개 이상 존재할 수 있는지를 의미하지만, 실제 DBMS의 쿼리를 실행해야하는 옵티마이저에게는 상당히 중요한 문제가 됩니다.
  * 유니크 인덱스에 대해 동등조건(equal, ==)으로 검색한다는 것은 1건의 레코드만 찾으면 더 찾지 않아도 되는 것을 알려주는 효과가 있습니다.

<br>

# 인덱스 형태별 분류 Clustered vs Non-Clustered Index
## Clustered Index
* 클러스터형 인덱스는 특정 칼럼을 기준으로 데이터들을 정렬시킵니다.
* 데이터가 테이블에 물리적으로 저장되는 순서를 정의합니다. 물리적으로 행을 재배열합니다.
* PK 설정 시 그 칼럼은 자동으로 클러스터형 인덱스가 만들어집니다.
* 인덱스 자체의 리프 페이지가 곧 데이터가 되어 테이블 자체가 인덱스가 됩니다.(따로 인덱스 페이지를 만들지 않습니다.)
* 데이터 입력, 수정, 삭제 시 항상 정렬 상태를 유지합니다. 따라서 검색 속도는 빠르지만(범위 검색 가능) 입력, 수정, 삭제는 느립니다.
* 테이블 당 한 개씩만 허용됩니다.

## Non-Clustered Index
* 논클러스터형 인덱스는 테이블 데이터와 함꼐 테이블에 저장되는 것이 아닌 별도의 장소에 저장됩니다. (책의 찾아보기처럼!)
* 하나의 테이블에 여러 개의 논클러스터형 인덱스를 설정할 수 있습니다.
* 레코드의 원본은 정렬되지 않고 인덱스 페이지만 정렬됩니다.

<br>

---

<br>

# INDEX 자료구조
## B-Tree란?
* 데이터베이스 인덱싱 알고리즘 가운데 가장 일반적으로 사용되고 가장 먼저 도입된 알고리즘으로 아직도 가장 범용적으로 사용되는 인덱스 알고리즘입니다.
* Binary Search Tree에서 발전되어 모든 리프노드들이 같은 레벨을 가질 수 있도록 자동으로 균형을 맞추는 트리입니다. (Balanced-Tree)
* B-Tree는 BST와 다르게 하나의 노드에 많은 수의 정보를 가지고 있을 수 있습니다. 
* 최대 M개의 자식을 가질 수 있는 B-Tree를 M차 B-Tree라고 합니다.

### 특성
* []: 올림을 표시합니다.
  - 노드는 [M/2]개 부터 M개 까지의 자식을 가질 수 있습니다.
  - 노드에는 [M/2]-1개 부터 M-1개의 키가 포함될 수 있습니다.
  - 노드의 키가 x개라면 자식의 수는 x+1개입니다.

# 다른 인덱스 자료구조를 사용할 때의 문제점

## BST(Binary Search Tree)
사진
- Average case vs. Worst case
  - 탐색의 시간 복잡도
  - 평균: O(logN)
  - 최악: O(N)

## RBT(Red Black Tree)
사진
* Red-Black Tree의 가장 큰 특징인 하나의 Node가 하나의 Key값을 가진다는 이유로 하나의 노드가 여러 데이터를 가지는 B-Tree에 비해 탐색 속도가 더 느립니다. 
* 또한 B-Tree는 모든 리프노드들이 같은 레벨을 갖습니다. 
* 반면 Root 부터 leaf 까지의 모든 경로 중 최소 경로와 최대 경로의 크기 비율은 2 보다 크지 않다는 특징을 가진 Red-Black Tree는 데이터의 개수가 기하급수적으로 늘어나게 되면 어떤 요소를 탐색하냐에 따라 탐색 시간이 달라질 수 있습니다.

## Hash-Table
사진
- Hash Table은 데이터가 정렬되어 있지 않습니다.
- 따라서 부등호(<>) 가 포함된 조건을 탐색한다면 Full Scan을 거쳐야만 합니다.
- 즉, 데이터가 정렬되어 있지 않다면, Index를 통해 항상 빠르게 값을 찾는다고 보장할 수가 없습니다.
